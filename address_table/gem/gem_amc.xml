<!--Trigger module -->
<node id="TRIGGER"  address="0x00800000"
      description="Trigger module handles everything related to sbit cluster data
                   (link synchronization, monitoring, local triggering, matching to L1A and reporting data to DAQ)"
      fw_is_module="true"
      fw_module_file="../gem/hdl/trigger/trigger.vhd"
      fw_user_clock_signal="ttc_clk_i.clk_40"
      fw_bus_clock_signal="ipb_clk_i"
      fw_bus_reset_signal="ipb_reset_i"
      fw_master_bus_signal="ipb_mosi_i"
      fw_slave_bus_signal="ipb_miso_o"
      fw_reg_addr_msb="12"
      fw_reg_addr_lsb="0">

  <node id="CTRL" address="0x0"
        description="Trigger control">
    <node id="MODULE_RESET" address="0x0" permission="w"
          description="Trigger module reset"
          fw_write_pulse_signal="reset_local"/>
    <node id="CNT_RESET" address="0x1" permission="w"
          description="Trigger counter reset"
          fw_write_pulse_signal="reset_cnt"
          sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
    <node id="OH_KILL_MASK" address="0x2" mask="0x00ffffff" permission="rw"
          description="OH trigger kill mask (kills all sbits from the corresponding OHs)"
          fw_signal="oh_mask"
          fw_default="0x000000"/>
    <node id="SECTOR_ID" address="0x2" mask="0x0f000000" permission="rw"
          description="Sector ID that gets embedded in the TX links to EMTF"
          fw_signal="sector_id"
          fw_default="0x0"/>
  </node>

  <node id="STATUS" address="0x10"
        description="Trigger status">
    <node id="OR_TRIGGER_RATE" address="0x0" permission="r"
          description="OR-Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster on any link"
          fw_signal="or_trigger_rate"
          sw_monitor_warn_min_threshold="1000000"/>
    <node id="OR_TRIGGER_CNT" address="0x1" permission="r"
          description="OR-Trigger count -- this trigger fires whenever there's at least one valid sbit cluster on any link"
          fw_signal="or_trigger_cnt"/>
  </node>

  <node id="SBIT_MONITOR" address="0x80"
        description="sbit monitor module which shows the first valid sbit clusters after a reset on the selected link">
    <node id="RESET" address="0x0" permission="w"
          description="Reset the sbit monitor module and re-arm for triggering"
          fw_write_pulse_signal="sbitmon_reset"/>
    <node id="OH_SELECT" address="0x1" mask="0x0000000f" permission="rw"
          description="Selects the OH to monitor and trigger on"
          fw_signal="sbitmon_link_select"
          fw_default="0x0"/>
    <node id="CLUSTER${CLUSTER_IDX}" address="0x2" mask="0x0000ffff" permission="r"
          description="Last cluster ${CLUSTER_IDX}"
          fw_signal="'0' &amp; sbitmon_sbits(${CLUSTER_IDX}).size &amp; '0' &amp; sbitmon_sbits(${CLUSTER_IDX}).address"
          generate="true" generate_size="8" generate_address_step="0x1" generate_idx_var="CLUSTER_IDX"/>
    <node id="L1A_DELAY" address="0xa" mask="0xffffffff" permission="r"
          description="Number of BX between this sbit and the subsequent L1A"
          fw_signal="sbitmon_l1a_delay"/>

    <node id="FIFO_EMPTY" address="0xb" mask="0x1" permission="r"
          description="S-bit monitor FIFO is empty"
          fw_signal="sbitmon_fifo_empty"/>
    <node id="FIFO_EN_L1A_TRIGGER" address="0xb" mask="0x2" permission="rw"
          description="Enable L1A trigger for S-bit DAQ"
          fw_default="0x0"
          fw_signal="sbitmon_fifo_en_l1a_trigger"/>
    <node id="FIFO_EN_SBIT_TRIGGER" address="0xb" mask="0x4" permission="rw"
          description="Enable L1A trigger for S-bit DAQ"
          fw_default="0x1"
          fw_signal="sbitmon_fifo_en_sbit_trigger"/>
    <node id="FIFO_TRIGGER_DELAY" address="0xb" mask="0x0000ffc0" permission="rw"
          description="Number of bx to delay the trigger (1-1024)"
          fw_default="0x7f"
          fw_signal="sbitmon_fifo_trigger_delay"/>
    <node id="FIFO_DATA" address="0xc" mask="0xffffffff" permission="r"
          fw_read_pulse_signal="sbitmon_fifo_rd_en"
          fw_read_ready_signal="sbitmon_fifo_valid"
          description="Read from the S-bit cluster FIFO, 2 clusters at a time"
          fw_signal="sbitmon_fifo_data"/>
  </node>

  <node id="OH${OH_IDX}" address="0x100"
        description="Trigger link for OH ${OH_IDX}"
        generate="true" generate_size="&NUM_OHS;" generate_address_step="0x100" generate_idx_var="OH_IDX">
    <node id="TRIGGER_RATE" address="0x0" permission="r"
          description="Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster"
          fw_signal="trigger_rate(${OH_IDX})"
          sw_monitor_warn_min_threshold="1000000"/>
    <node id="TRIGGER_CNT" address="0x1" permission="r"
          description="Trigger count -- this trigger fires whenever there's at least one valid sbit cluster"
          fw_signal="trigger_cnt(${OH_IDX})"
          sw_monitor_warn_min_threshold="1000000"/>
    <node id="BC0_MISALIGN_CNT" address="0x2" permission="r"
          description="This counter is incremented whenever the BC0 marker value doesn't match between the two trigger links (GE1/1 only)"
          fw_signal="bc0_misalign_cnt(${OH_IDX})"
          sw_val_good="self == 0"/>
    <node id="CLUSTER_COUNT_${CS_IDX}_RATE" address="0x10" permission="r"
          description="Rate of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
          fw_signal="cluster_cnt_rate(${OH_IDX} * 9 + ${CS_IDX})"
          generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
    <node id="CLUSTER_COUNT_${CS_IDX}_CNT" address="0x20" permission="r"
          description="Count of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
          fw_signal="cluster_cnt(${OH_IDX} * 9 + ${CS_IDX})"
          generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
    <node id="LINK0_SBIT_OVERFLOW_CNT" address="0xa0" mask="0x0000ffff" permission="r"
          description="Count of overflow markers received from OH on lin 0"
          fw_signal="sbit_overflow_cnt(${OH_IDX})(15 downto 0)"
          sw_monitor_error_min_threshold="100"/>
    <node id="LINK1_SBIT_OVERFLOW_CNT" address="0xa0" mask="0xffff0000" permission="r"
          description="Count of overflow markers received from OH on link 1"
          fw_signal="sbit_overflow_cnt(${OH_IDX})(31 downto 16)"
          sw_monitor_error_min_threshold="100"/>
    <node id="LINK0_MISSED_COMMA_CNT" address="0xa1" mask="0x0000ffff" permission="r"
          description="Count of missed comma character at the expected time for link 0 (this indicates an out-of-sync condition)"
          fw_signal="missed_comma_cnt(${OH_IDX})(15 downto 0)"
          sw_val_good="self == 0"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK1_MISSED_COMMA_CNT" address="0xa1" mask="0xffff0000" permission="r"
          description="Count of missed comma character at the expected time for link 1 (this indicates an out-of-sync condition)"
          fw_signal="missed_comma_cnt(${OH_IDX})(31 downto 16)"
          sw_val_good="self == 0"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK0_OVERFLOW_CNT" address="0xa3" mask="0x0000ffff" permission="r"
          description="Count of overflow occurances in the sync FIFO for link 0"
          fw_signal="link_overflow_cnt(${OH_IDX})(15 downto 0)"
          sw_val_good="self == 0"
          sw_val_warn="self &lt; 10"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK1_OVERFLOW_CNT" address="0xa3" mask="0xffff0000" permission="r"
          description="Count of overflow occurances in the sync FIFO for link 1"
          fw_signal="link_overflow_cnt(${OH_IDX})(31 downto 16)"
          sw_val_good="self == 0"
          sw_val_warn="self &lt; 10"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK0_UNDERFLOW_CNT" address="0xa4" mask="0x0000ffff" permission="r"
          description="Count of underflow occurances in the sync FIFO for link 0"
          fw_signal="link_underflow_cnt(${OH_IDX})(15 downto 0)"
          sw_val_good="self == 0"
          sw_val_warn="self &lt; 10"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK1_UNDERFLOW_CNT" address="0xa4" mask="0xffff0000" permission="r"
          description="Count of underflow occurances in the sync FIFO for link 1"
          fw_signal="link_underflow_cnt(${OH_IDX})(31 downto 16)"
          sw_val_good="self == 0"
          sw_val_warn="self &lt; 10"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK0_NOT_IN_TABLE_CNT" address="0xa5" mask="0x0000ffff" permission="r"
          description="Count of 8b10b not_in_table errors for link 0"
          fw_signal="not_in_table_err_cnt(${OH_IDX})(15 downto 0)"
          sw_val_good="self == 0"
          sw_monitor_error_min_threshold="1"/>
    <node id="LINK1_NOT_IN_TABLE_CNT" address="0xa5" mask="0xffff0000" permission="r"
          description="Count of 8b10b not_in_table errors for link 1"
          fw_signal="not_in_table_err_cnt(${OH_IDX})(31 downto 16)"
          sw_val_good="self == 0"
          sw_monitor_error_min_threshold="1"/>
  </node>

</node>
<!--end trigger module -->

<!--GEM System module -->
<node id="GEM_SYSTEM"  address="0x00900000"
      description="This module is controlling GEM AMC System wide settings"
      fw_is_module="true"
      fw_module_file="../gem/hdl/misc/gem_system_regs.vhd"
      fw_user_clock_signal="ttc_clks_i.clk_40"
      fw_bus_clock_signal="ipb_clk_i"
      fw_bus_reset_signal="ipb_reset_i"
      fw_master_bus_signal="ipb_mosi_i"
      fw_slave_bus_signal="ipb_miso_o"
      fw_reg_addr_msb="16"
      fw_reg_addr_lsb="0">

  <node id="CTRL" address="0x0">
    <node id="GLOBAL_RESET" address="0x0" permission="w"
          description="Global reset of the GEM logic (resets all modules)"
          fw_write_pulse_signal="global_reset_trig"
          sw_ctrl_configure_set="0x1"/>
    <node id="LINK_RESET" address="0x1" permission="w"
          description="Reset the links to and from OHs and redo VFAT3 sync procedure"
          fw_write_pulse_signal="manual_link_reset_o"
          sw_ctrl_configure_set="0x1"/>
    <node id="IPBUS_RESET" address="0x2" permission="w"
          description="Reset of all registers to their default value"
          fw_write_pulse_signal="ipbus_reset_trig"
          sw_ctrl_configure_set="0x1"/>
    <node id="GBT_RESET" address="0x3" permission="w"
          description="Reset all the GBT cores"
          fw_write_pulse_signal="gbt_reset_o"
          sw_ctrl_configure_set="0x1"/>
  </node>

  <node id="RELEASE" address="0x30">
    <node id="SLR" address="0x0" mask="0x30000000" permission="r"
          description="SLR number of this GEM block"
          fw_signal="std_logic_vector(to_unsigned(g_SLR, 2))"/>
    <node id="GEM_STATION" address="0x0" mask="0x00000003" permission="r"
          description="GEM station that this firmware was compiled for (0 means ME0, 1 means GE1/1, 2 means GE2/1)"
          fw_signal="std_logic_vector(to_unsigned(CFG_GEM_STATION(g_SLR), 2))"
          fw_enum="['ME0', 'GE1/1', 'GE2/1']"/>
    <node id="OH_VERSION" address="0x0" mask="0x0000000c" permission="r"
          description="Version of the OH supported by this firmware build."
          fw_signal="std_logic_vector(to_unsigned(CFG_OH_VERSION(g_SLR), 2))"/>
    <node id="NUM_OF_OH" address="0x0" mask="0x000003f0" permission="r"
          description="Number of supported optohybrids"
          fw_signal="std_logic_vector(to_unsigned(CFG_NUM_OF_OHs(g_SLR), 6))"/>
    <node id="NUM_OF_GBTS_PER_OH" address="0x0" mask="0x0000f000" permission="r"
          description="Number of GBTs per optohybrid"
          fw_signal="std_logic_vector(to_unsigned(CFG_NUM_GBTS_PER_OH(g_SLR), 4))"/>
    <node id="NUM_VFATS_PER_OH" address="0x0" mask="0x001f0000" permission="r"
          description="Number of VFATs per optohybrid"
          fw_signal="std_logic_vector(to_unsigned(CFG_NUM_VFATS_PER_OH(g_SLR), 5))"/>
    <node id="USE_TRIG_TX_LINKS" address="0x0" mask="0x00000400" permission="r"
          description="Indicates whether or not trigger TX links are supported by this firmware build"
          fw_signal="'1' when CFG_USE_TRIG_TX_LINKS else '0'"/>
    <node id="NUM_TRIG_TX_LINKS" address="0x0" mask="0x01e00000" permission="r"
          description="Number of supported trigger TX links"
          fw_signal="std_logic_vector(to_unsigned(CFG_NUM_TRIG_TX, 4))"/>
    <node id="USE_LOCAL_DAQ_LINK" address="0x0" mask="0x00000800" permission="r"
          description="Indicates whether or not local DAQ link is supported by this firmware build"
          fw_signal="'1' when CFG_USE_SPY_LINK(g_SLR) else '0'"/>
    <node id="OH_LINK_CONFIG" address="0x5">
      <node id="OH${OH_IDX}" address="0x0"
            description="OH${OH_IDX} link numbers"
            generate="true" generate_size="&NUM_OHS;" generate_address_step="0x00000005" generate_idx_var="OH_IDX">
        <node id="GBT0_TX" address="0x0" mask="0x000000ff" permission="r"
              description="OH${OH_IDX} GBT0 TX link number"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(0).tx, 8))"/>
        <node id="GBT0_RX" address="0x0" mask="0x0000ff00" permission="r"
              description="OH${OH_IDX} GBT0 RX link number"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(0).rx, 8))"/>
        <node id="GBT1_TX" address="0x0" mask="0x00ff0000" permission="r"
              description="OH${OH_IDX} GBT1 TX link number"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(1).tx, 8))"/>
        <node id="GBT1_RX" address="0x0" mask="0xff000000" permission="r"
              description="OH${OH_IDX} GBT1 RX link number"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(1).rx, 8))"/>
        <node id="GBT2_TX" address="0x1" mask="0x000000ff" permission="r"
              description="OH${OH_IDX} GBT2 TX link number" ignore="&STATION;==2"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(2).tx, 8))"/>
        <node id="GBT2_RX" address="0x1" mask="0x0000ff00" permission="r"
              description="OH${OH_IDX} GBT2 RX link number" ignore="&STATION;==2"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(2).rx, 8))"/>
        <node id="GBT3_TX" address="0x1" mask="0x00ff0000" permission="r"
              description="OH${OH_IDX} GBT3 TX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(3).tx, 8))"/>
        <node id="GBT3_RX" address="0x1" mask="0xff000000" permission="r"
              description="OH${OH_IDX} GBT3 RX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(3).rx, 8))"/>
        <node id="GBT4_TX" address="0x2" mask="0x000000ff" permission="r"
              description="OH${OH_IDX} GBT4 TX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(4).tx, 8))"/>
        <node id="GBT4_RX" address="0x2" mask="0x0000ff00" permission="r"
              description="OH${OH_IDX} GBT4 RX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(4).rx, 8))"/>
        <node id="GBT5_TX" address="0x2" mask="0x00ff0000" permission="r"
              description="OH${OH_IDX} GBT5 TX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(5).tx, 8))"/>
        <node id="GBT5_RX" address="0x2" mask="0xff000000" permission="r"
              description="OH${OH_IDX} GBT5 RX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(5).rx, 8))"/>
        <node id="GBT6_TX" address="0x3" mask="0x000000ff" permission="r"
              description="OH${OH_IDX} GBT6 TX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(6).tx, 8))"/>
        <node id="GBT6_RX" address="0x3" mask="0x0000ff00" permission="r"
              description="OH${OH_IDX} GBT6 RX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(6).rx, 8))"/>
        <node id="GBT7_TX" address="0x3" mask="0x00ff0000" permission="r"
              description="OH${OH_IDX} GBT7 TX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(7).tx, 8))"/>
        <node id="GBT7_RX" address="0x3" mask="0xff000000" permission="r"
              description="OH${OH_IDX} GBT7 RX link number" ignore="&STATION;!=0"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).gbt_links(7).rx, 8))"/>
        <node id="TRIG_RX0" address="0x4" mask="0x000000ff" permission="r"
              description="OH${OH_IDX} trigger RX0 link number" ignore="&STATION;!=1"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).trig_rx_links(0).rx, 8))"/>
        <node id="TRIG_RX1" address="0x4" mask="0x0000ff00" permission="r"
              description="OH${OH_IDX} trigger RX1 link number" ignore="&STATION;!=1"
              fw_signal="std_logic_vector(to_unsigned(CFG_OH_LINK_CONFIG_ARR(g_SLR)(${OH_IDX}).trig_rx_links(1).rx, 8))"/>
      </node>
    </node>
    <node id="TRIG_TX_LINK_CONFIG" address="0x105">
      <node id="TX0_LINK" address="0x0" mask="0x000000ff" permission="r"
            description="Trigger TX link number 0 link number" ignore="0 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(0), 8))"/>
      <node id="TX1_LINK" address="0x0" mask="0x0000ff00" permission="r"
            description="Trigger TX link number 1 link number" ignore="1 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(1), 8))"/>
      <node id="TX2_LINK" address="0x0" mask="0x00ff0000" permission="r"
            description="Trigger TX link number 2 link number" ignore="2 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(2), 8))"/>
      <node id="TX3_LINK" address="0x0" mask="0xff000000" permission="r"
            description="Trigger TX link number 3 link number" ignore="3 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(3), 8))"/>
      <node id="TX4_LINK" address="0x1" mask="0x000000ff" permission="r"
            description="Trigger TX link number 4 link number" ignore="4 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(4), 8))"/>
      <node id="TX5_LINK" address="0x1" mask="0x0000ff00" permission="r"
            description="Trigger TX link number 5 link number" ignore="5 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(5), 8))"/>
      <node id="TX6_LINK" address="0x1" mask="0x00ff0000" permission="r"
            description="Trigger TX link number 6 link number" ignore="6 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(6), 8))"/>
      <node id="TX7_LINK" address="0x1" mask="0xff000000" permission="r"
            description="Trigger TX link number 7 link number" ignore="7 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(7), 8))"/>
      <node id="TX8_LINK" address="0x2" mask="0x000000ff" permission="r"
            description="Trigger TX link number 8 link number" ignore="8 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(8), 8))"/>
      <node id="TX9_LINK" address="0x2" mask="0x0000ff00" permission="r"
            description="Trigger TX link number 9 link number" ignore="9 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(9), 8))"/>
      <node id="TX10_LINK" address="0x2" mask="0x00ff0000" permission="r"
            description="Trigger TX link number 10 link number" ignore="10 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(10), 8))"/>
      <node id="TX11_LINK" address="0x2" mask="0xff000000" permission="r"
            description="Trigger TX link number 11 link number" ignore="11 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(11), 8))"/>
      <node id="TX12_LINK" address="0x3" mask="0x000000ff" permission="r"
            description="Trigger TX link number 12 link number" ignore="12 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(12), 8))"/>
      <node id="TX13_LINK" address="0x3" mask="0x0000ff00" permission="r"
            description="Trigger TX link number 13 link number" ignore="13 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(13), 8))"/>
      <node id="TX14_LINK" address="0x3" mask="0x00ff0000" permission="r"
            description="Trigger TX link number 14 link number" ignore="14 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(14), 8))"/>
      <node id="TX15_LINK" address="0x3" mask="0xff000000" permission="r"
            description="Trigger TX link number 15 link number" ignore="15 >= &NUM_TRIG_TX_LINKS;"
            fw_signal="std_logic_vector(to_unsigned(CFG_TRIG_TX_LINK_CONFIG_ARR(g_SLR)(15), 8))"/>
    </node>

    <node id="LOCAL_DAQ_LINK" address="0x115" mask="0x000000ff" permission="r"
          description="Local DAQ link number"
          fw_signal="std_logic_vector(to_unsigned(CFG_SPY_LINK(g_SLR), 8))"/>
  </node>

  <node id="VFAT3" address="0x150">
    <node id="SC_ONLY_MODE" address="0x1" mask="0x00000002" permission="rw"
          description="When this is set to 0 then comm port of VFAT3s will be set to normal mode, otherwise they will be set to slow-control-only mode. This setting is applied to all VFATs during link reset and whenever this value is changed."
          fw_signal="vfat3_sc_only_mode" fw_default="0b0"/>
    <node id="USE_OH_V3B_MAPPING" address="0x1" mask="0x00000004" permission="rw"
          description="If set high, then will use the v3b elink assignments for the OH FPGA communication, otherwise v3a"
          fw_signal="use_v3b_elink_mapping" fw_default="0b1"/>
    <node id="VFAT0_HDLC_ADDRESS" address="0x2" mask="0x0000000f" permission="rw"
          description="HDLC address for VFAT0: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(0)" fw_default="VFAT3_HDLC_ADDRESSES(0)"/>
    <node id="VFAT1_HDLC_ADDRESS" address="0x2" mask="0x000000f0" permission="rw"
          description="HDLC address for VFAT1: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(1)" fw_default="VFAT3_HDLC_ADDRESSES(1)"/>
    <node id="VFAT2_HDLC_ADDRESS" address="0x2" mask="0x00000f00" permission="rw"
          description="HDLC address for VFAT2: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(2)" fw_default="VFAT3_HDLC_ADDRESSES(2)"/>
    <node id="VFAT3_HDLC_ADDRESS" address="0x2" mask="0x0000f000" permission="rw"
          description="HDLC address for VFAT3: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(3)" fw_default="VFAT3_HDLC_ADDRESSES(3)"/>
    <node id="VFAT4_HDLC_ADDRESS" address="0x2" mask="0x000f0000" permission="rw"
          description="HDLC address for VFAT4: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(4)" fw_default="VFAT3_HDLC_ADDRESSES(4)"/>
    <node id="VFAT5_HDLC_ADDRESS" address="0x2" mask="0x00f00000" permission="rw"
          description="HDLC address for VFAT5: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(5)" fw_default="VFAT3_HDLC_ADDRESSES(5)"/>
    <node id="VFAT6_HDLC_ADDRESS" address="0x2" mask="0x0f000000" permission="rw"
          description="HDLC address for VFAT6: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(6)" fw_default="VFAT3_HDLC_ADDRESSES(6)"/>
    <node id="VFAT7_HDLC_ADDRESS" address="0x2" mask="0xf0000000" permission="rw"
          description="HDLC address for VFAT7: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(7)" fw_default="VFAT3_HDLC_ADDRESSES(7)"/>
    <node id="VFAT8_HDLC_ADDRESS" address="0x3" mask="0x0000000f" permission="rw"
          description="HDLC address for VFAT8: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(8)" fw_default="VFAT3_HDLC_ADDRESSES(8)"/>
    <node id="VFAT9_HDLC_ADDRESS" address="0x3" mask="0x000000f0" permission="rw"
          description="HDLC address for VFAT9: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(9)" fw_default="VFAT3_HDLC_ADDRESSES(9)"/>
    <node id="VFAT10_HDLC_ADDRESS" address="0x3" mask="0x00000f00" permission="rw"
          description="HDLC address for VFAT10: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(10)" fw_default="VFAT3_HDLC_ADDRESSES(10)"/>
    <node id="VFAT11_HDLC_ADDRESS" address="0x3" mask="0x0000f000" permission="rw"
          description="HDLC address for VFAT11: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(11)" fw_default="VFAT3_HDLC_ADDRESSES(11)"/>
    <node id="VFAT12_HDLC_ADDRESS" address="0x3" mask="0x000f0000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT12: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(12)" fw_default="VFAT3_HDLC_ADDRESSES(12)"/>
    <node id="VFAT13_HDLC_ADDRESS" address="0x3" mask="0x00f00000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT13: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(13)" fw_default="VFAT3_HDLC_ADDRESSES(13)"/>
    <node id="VFAT14_HDLC_ADDRESS" address="0x3" mask="0x0f000000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT14: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(14)" fw_default="VFAT3_HDLC_ADDRESSES(14)"/>
    <node id="VFAT15_HDLC_ADDRESS" address="0x3" mask="0xf0000000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT15: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(15)" fw_default="VFAT3_HDLC_ADDRESSES(15)"/>
    <node id="VFAT16_HDLC_ADDRESS" address="0x4" mask="0x0000000f" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT16: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(16)" fw_default="VFAT3_HDLC_ADDRESSES(16)"/>
    <node id="VFAT17_HDLC_ADDRESS" address="0x4" mask="0x000000f0" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT17: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(17)" fw_default="VFAT3_HDLC_ADDRESSES(17)"/>
    <node id="VFAT18_HDLC_ADDRESS" address="0x4" mask="0x00000f00" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT18: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(18)" fw_default="VFAT3_HDLC_ADDRESSES(18)"/>
    <node id="VFAT19_HDLC_ADDRESS" address="0x4" mask="0x0000f000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT19: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(19)" fw_default="VFAT3_HDLC_ADDRESSES(19)"/>
    <node id="VFAT20_HDLC_ADDRESS" address="0x4" mask="0x000f0000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT20: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(20)" fw_default="VFAT3_HDLC_ADDRESSES(20)"/>
    <node id="VFAT21_HDLC_ADDRESS" address="0x4" mask="0x00f00000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT21: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(21)" fw_default="VFAT3_HDLC_ADDRESSES(21)"/>
    <node id="VFAT22_HDLC_ADDRESS" address="0x4" mask="0x0f000000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT22: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(22)" fw_default="VFAT3_HDLC_ADDRESSES(22)"/>
    <node id="VFAT23_HDLC_ADDRESS" address="0x4" mask="0xf0000000" permission="rw" ignore="&STATION;==2"
          description="HDLC address for VFAT23: use 0 when using GE1/1 VFAT3 hybrids, otherwise depends on the GEB addressing resistors (firmware default should work for production GEBs)"
          fw_signal="vfat_hdlc_address_arr(23)" fw_default="VFAT3_HDLC_ADDRESSES(23)"/>
  </node>

  <node id="TESTS" address="0x200">
    <node id="GBT_LOOPBACK_EN" address="0x0" mask="0x00000001" permission="rw"
          description="GBT Loopback test enable -- if this is true then all GBT links are redirected to the loopback test
                       module and the test module is enabled (communication with optohybrid is not possible during the test)"
          fw_signal="loopback_gbt_test_en" fw_default="0b0"
          sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0"/>
  </node>

  <node id="PROMLESS" address="0x400">
    <node id="FIRMWARE_SIZE" address="0x10" mask="0xffffffff" permission="rw"
          description="Number of bytes in the OH firmware"
          fw_signal="promless_fw_size" fw_default="0x005363f2"/>
    <node id="LOAD_REQUEST_CNT" address="0x0" mask="0x0000ffff" permission="r"
          description="Number of OH programming requests (note, the counter is 16bit rolling)"
          fw_signal="promless_stats_i.load_request_cnt"/>
    <node id="LOAD_SUCCESS_CNT" address="0x0" mask="0xffff0000" permission="r"
          description="Number of successful OH programming attempts (note, the counter is 16bit rolling)"
          fw_signal="promless_stats_i.success_cnt"/>
    <node id="LOAD_FAIL_CNT" address="0x1" mask="0x0000ffff" permission="r"
          description="Number of failed OH programming attempts (note, the counter is 16bit rolling)"
          fw_signal="promless_stats_i.fail_cnt"/>
    <node id="STREAM_GAP_CNT" address="0x1" mask="0xffff0000" permission="r"
          description="Number of times that a gap has been detected in the bitfile stream before reaching the end (note, the counter is 16bit rolling)"
          fw_signal="promless_stats_i.gap_detect_cnt"/>
    <node id="LOADER_OVF_UNF_CNT" address="0x2" mask="0x0000ffff" permission="r"
          description="Number of times that the promless loader has reported a FIFO overflow or underflow (note, the counter is 16bit rolling)"
          fw_signal="promless_stats_i.loader_ovf_unf_cnt"/>
  </node>

  <node id="REG_ACCESS_MONITOR" address="0x500">
    <node id="TRANSACT_CNT" address="0x0" mask="0x0000ffff" permission="r"
          description="Total number of register access transactions (note, the counter is 16bit rolling)"
          fw_signal="ipb_mon_trans_cnt"/>
    <node id="TRANSACT_ERR_CNT" address="0x0" mask="0x7fff0000" permission="r"
          description="Total number of register access errors (note, the counter is 16bit rolling)"
          fw_signal="ipb_mon_err_cnt"/>
    <node id="LAST_TRANS_ERR" address="0x0" mask="0x80000000" permission="r"
          description="This flag indicates whether or not the last transaction was a success (0) or if it ended in error (1)"
          fw_signal="ipb_mon_last_trans_err"/>
  </node>
</node>

<!--GEM Tests module -->
<node id="GEM_TESTS"  address="0x00A00000"
      description="This module is controlling various hardware tests e.g. fiber loopback"
      fw_is_module="true"
      fw_module_file="../gem/hdl/tests/gem_tests.vhd"
      fw_user_clock_signal="ttc_clk_i.clk_40"
      fw_bus_clock_signal="ipb_clk_i"
      fw_bus_reset_signal="ipb_reset_i"
      fw_master_bus_signal="ipb_mosi_i"
      fw_slave_bus_signal="ipb_miso_o"
      fw_reg_addr_msb="16"
      fw_reg_addr_lsb="0">

  <node id="CTRL" address="0x0">
    <node id="RESET" address="0x0" permission="w"
          description="reset all test modules"
          fw_write_pulse_signal="reset_local"/>
  </node>

  <node id="OH_LOOPBACK" address="0x1000"
          description="This module controls the OH PRBS loopback tester (this tester can be connected to one OH at a time by using the OH_SELECT register). This module sends a PRBS7 8b sequence to all elinks of the chosen OH, and checks each elink of that OH with the same sequence checker">
    <node id="CTRL" address="0x0">
      <node id="RESET" address="0x0" permission="w"
            description="reset the PRBS loopback module"
            fw_write_pulse_signal="gbt_loop_reset"/>
      <node id="OH_SELECT" address="0x1" mask="0x0000000f" permission="rw"
        description="This register sets the index of the OH that the loopback tester is going to be testing"
        fw_signal="gbt_loop_oh_select" fw_default="0x0"/>
      <node id="INJECT_ERR" address="0x2" permission="w"
        description="Writing to this register will result in one error being injected to the PRBS TX data going to the OH"
        fw_write_pulse_signal="gbt_loop_err_inject"/>
    </node>
    <node id="GBT_${GBT_IN_OH_IDX}"  address="0x10"
          description="Link specific registers for GBT ${GBT_IN_OH_IDX}"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x100" generate_idx_var="GBT_IN_OH_IDX">

      <node id="ELINK_${ELINK_IDX}"  address="0x0"
            description="E-link specific registers for e-link ${ELINK_IDX}"
            generate="true" generate_size="14" generate_address_step="0x2" generate_idx_var="ELINK_IDX">

        <node id="PRBS_LOCKED" mask="0x80000000" permission="r" address="0x0"
              description="Indicates whether or not the PRBS7 checker is locked on this elink"
              fw_signal="gbt_loop_locked_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})"/>
        <node id="MEGA_WORD_CNT" permission="r" address="0x1"
              description="Number of generated data words in units of one million received by this RX elink after PRBS checker has locked"
              fw_signal="gbt_loop_mega_word_cnt_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})"/>
        <node id="ERROR_CNT" mask="0x7fffffff" permission="r" address="0x0"
              description="Number of PRBS7 errors found in the received data for this elink"
              fw_signal="gbt_loop_error_cnt_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})(30 downto 0)"/>
      </node>
    </node>
  </node>

  <node id="VFAT_DAQ_MONITOR" address="0x2000"
          description="This module listens to the DAQ data of 24 VFATs from a selected OH
                       and counts the number of good events received and the number of times a selected channel (or any channel) has fired.
                       This is useful for various scan routines.">
    <node id="CTRL" address="0x0">
      <node id="RESET" address="0x0" permission="w"
            description="reset all the VFAT DAQMON modules"
            fw_write_pulse_signal="vfat_daqmon_reset"/>
    <node id="ENABLE" address="0x1" mask="0x00000001" permission="rw"
        description="This register lets you enable and disable all VFAT DAQMON modules. When disabled all the counters are frozen."
        fw_signal="vfat_daqmon_enable" fw_default="0b0"/>
    <node id="OH_SELECT" address="0x1" mask="0x000000f0" permission="rw"
        description="Selects the desired OH"
        fw_signal="vfat_daqmon_oh_select" fw_default="0x0"/>
    <node id="VFAT_CHANNEL_SELECT" address="0x1" mask="0x00007f00" permission="rw"
        description="Selects the VFAT channel number to listen to"
        fw_signal="vfat_daqmon_chan_select" fw_default="0x0"/>
    <node id="VFAT_CHANNEL_GLOBAL_OR" address="0x1" mask="0x00008000" permission="rw"
        description="If this is set to 1 then the VFAT DAQMONs will OR all the VFAT channels together and ignore the VFAT_CHANNEL_SELECT"
        fw_signal="vfat_daqmon_chan_global_or" fw_default="0x0"/>
    </node>
    <node id="VFAT${VFAT_IDX}"  address="0x10"
          description="VFAT DAQMON counters for VFAT${VFAT_IDX}"
          generate="true" generate_size="&NUM_VFATS_PER_OH;" generate_address_step="0x10" generate_idx_var="VFAT_IDX">

      <node id="GOOD_EVENTS_COUNT" mask="0x0000ffff" permission="r" address="0x0"
            description="Number of good events received from this VFAT (good event means that CRC check has passed ok)"
            fw_signal="vfat_daqmon_good_evt_cnt_arr(${VFAT_IDX})"/>
      <node id="CHANNEL_FIRE_COUNT" mask="0xffff0000" permission="r" address="0x0"
            description="Number of times the selected channel has fired"
            fw_signal="vfat_daqmon_chan_fire_cnt_arr(${VFAT_IDX})"/>

    </node>
  </node>

  <node id="GBE_TEST" address="0x3000">
      <node id="ENABLE" address="0x0" mask="0x00000001" permission="rw"
            description="Enable this module, note that this will cause the GbE link to be disconnected from DAQ and only be connected to the test module where you'll be able to generate your own packets."
            fw_signal="gbe_test_enable" fw_default="0b0"/>
      <node id="PUSH_GBE_DATA" address="0x1" mask="0x0003ffff" permission="w"
            description="Writing this register will push this word into a fifo which holds the packet to be transmitted uppon the start command. Note that bits [17:16] denote if the characters in bits [15:0] are K characters or not."
            fw_signal="gbe_user_data" fw_write_pulse_signal="gbe_user_data_en" fw_default="0x0"/>
      <node id="START_TRANSMIT" address="0x2" permission="w" mask="0x80000000"
            description="Writing to this register will trigger sending of the packet that's in the fifo."
            fw_write_pulse_signal="gbe_send_en"/>
      <node id="BUSY" address="0x3" mask="0x00000001" permission="r"
            description="This is 1 while a packet transmission is ongoing"
            fw_signal="gbe_busy"/>
      <node id="EMPTY" address="0x3" mask="0x00000002" permission="r"
            description="This is 1 when the fifo is empty, and ready for a new packet push"
            fw_signal="gbe_empty"/>
      <node id="MANUAL_READ_ENABLE" address="0x4" mask="0x00000001" permission="rw"
            description="If this is set high, manual reading of the FIFO is enabled"
            fw_signal="gbe_manual_rd_enabled" fw_default="0b0"/>
      <node id="MANUAL_READ" address="0x5" mask="0x0003ffff" permission="r"
            description="If manual reading is enabled, reading this register will read the first word in the fifo (and consume it)"
            fw_signal="gbe_manual_rd_data" fw_read_pulse_signal="gbe_manual_rd_en" fw_read_ready_signal="gbe_manual_rd_valid"/>
  </node>

</node>

<!--DAQ module -->
<node id="DAQ"  address="0x00700000"
      description="DAQ module buffers track data, builds events, analyses the data for consistency
                   and ships off the events with all the needed headers and trailers to AMC13 over DAQLink"
      fw_is_module="true"
      fw_module_file="../gem/hdl/daq/daq.vhd"
      fw_user_clock_signal="ipb_clk_i"
      fw_bus_clock_signal="ipb_clk_i"
      fw_bus_reset_signal="ipb_reset_i"
      fw_master_bus_signal="ipb_mosi_i"
      fw_slave_bus_signal="ipb_miso_o"
      fw_reg_addr_msb="8"
      fw_reg_addr_lsb="0">

  <node id="CONTROL"  address="0x0"
        description="DAQ Control">
    <node id="DAQ_ENABLE"         address="0x0" mask="0x00000001" permission="rw"
          description="If this is set to 0, there will be no data sent to AMC13 and TTS state will always be READY (0x8)"
          fw_signal="daq_enable" fw_default="0b0"
          sw_units="bool"/>
    <node id="DAQ_LINK_RESET"     address="0x0" mask="0x00000004" permission="rw"
          description="Directly connected to DAQLink module reset port. BU is
                       advising against ever using it except for powerup, but it
                       may clear some error conditions (like daqlink_almost_ful
                       stuck at 1). AMC13 reset is probably required after this."
          fw_signal="reset_daqlink_ipb" fw_default="0b0"
          sw_units="bool"/>
    <node id="RESET"              address="0x0" mask="0x00000008" permission="rw"
          description="Clears all FIFOs, state flags and counters. It also stops and
                       resets all state machines (no events will be built, recorded
                       or sent during reset)
                       When set to 1, it will be held in reset state until 0 is
                       explicitly written (this can be changed in the future if
                       necessary)"
          fw_signal="reset_local" fw_default="0b0"
          sw_units="bool"/>
    <node id="ZERO_SUPPRESSION_EN"              address="0x0" mask="0x00000002" permission="rw"
          description="Enable/disable VFAT2 zero suppression"
          fw_signal="zero_suppression_en" fw_default="0b0"
          sw_units="bool"/>
    <node id="TTS_OVERRIDE"       address="0x0" mask="0x000000f0" permission="rw"
          description="When not 0, it will override the AMC TTS state with the
                       provided value (e.g. writing 0x8 will force AMC to always be
                       in TTS READY state)"
          fw_signal="tts_override" fw_default="0x0"
          sw_val_warn="self != 0"
          sw_enum="['DISABLED', 'WARNING', 'OUT-OF-SYNC', 'UNKNOWN', 'BUSY', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'READY', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'ERROR', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN']"/>
    <node id="INPUT_ENABLE_MASK"  address="0x0" mask="0xffffff00" permission="rw"
          description="This is a bitmask telling AMC to enable certain inputs (least
                       significant bit is input 0). Only first is enabled by default"
          fw_signal="input_mask" fw_default="0x1"/>
    <node id="DAV_TIMEOUT"        address="0x1"  mask="0x00ffffff" permission="rw"
          description="This setting controls how long DAQ will wait for individual
                       inputs to report data before calling it timed-out  (if timeout
                       occurs a header and trailer for that chamber will still be
                       inserted and timeout flag will be set there, though no VFAT
                       payload will be present). Units = clock cycles @ 25MHz
                       (current DAQLink clk frequency)"
          fw_signal="dav_timeout" fw_default="0x00500"/>
    <node id="DBG_FANOUT_ENABLE"        address="0x1"  mask="0x01000000" permission="rw"
          description="This register enables and disables the fanout feature.
                       This feature is used for testing only. When enabled it will
                       take the data input from one OH and fan it out to all DAQ module
                       inputs. The input to be used is controlled by DBG_FANOUT_INPUT reg."
          fw_signal="dbg_fanout_enable" fw_default="0b0"
          sw_val_warn="self == 1"
          sw_units="bool"/>
    <node id="DBG_FANOUT_INPUT"        address="0x1"  mask="0xf0000000" permission="rw"
          description="Selects the input to be faned out when the fanout feature is enabled (see DBG_FANOUT_ENABLE)."
          fw_signal="dbg_fanout_input" fw_default="0x0"/>
    <node id="CALIBRATION_MODE_EN"       address="0x2"  mask="0x00000080" permission="rw"
          description="When set, this enables calibration mode data format, which strips the VFAT payload of most of the data, just leaving 8 bits per VFAT, where [4:0] is the VFAT position, [6:5] is EC, and bit 7 is the chanel information for the channel selected in CALIBRATION_MODE_CHAN (see below)"
          fw_signal="format_calib_mode" fw_default="0b0"
          sw_units="bool"/>
    <node id="CALIBRATION_MODE_CHAN"       address="0x2"  mask="0x0000007f" permission="rw"
          description="Channel number for which data will be included in the calibration mode data format (see CALIBRATION_MODE_EN)"
          fw_signal="format_calib_chan" fw_default="0b0000000"/>
    <node id="IGNORE_DAQLINK" address="0x2" mask="0x00000100" permission="rw"
          description="If this is set to 1 then there will be no data sent to DAQLink (AMC13 / SlinkRocket), but events will still be built and sent to spy path ignoring the DAQLink state"
          fw_signal="ignore_daqlink" fw_default="0b0"
          sw_units="bool"/>
    <node id="FREEZE_ON_ERROR"        address="0x2"  mask="0x00000200" permission="rw"
          description="This is a debug feature which when turned on will start sending only IDLE words to all input processors and block L1As as soon as TTS error is detected. This gets reset with a DAQ module reset or a TTC resync."
          fw_signal="freeze_on_error" fw_default="0x0"
          sw_units="bool"/>
    <node id="RESET_TILL_RESYNC"        address="0x2"  mask="0x00000400" permission="rw"
          description="If this is true, then after the user removes the reset, this module will still stay in reset till the resync is received. This is handy for starting to take data in the middle of an active run."
          fw_signal="reset_till_resync" fw_default="0x0"
          sw_units="bool"/>
    <node id="FED_ID"     address="0x3" permission="rw"
          description="FED ID, used in SlinkRocket header"
          fw_signal="fed_id" fw_default="0x0000033e"/>
    <node id="SPY"  address="0xf" description="Spy path control registers">
        <node id="SPY_SKIP_ETH_HEADER"        address="0x0"  mask="0x00000001" permission="rw"
              description="If this is true, then ethernet headers will be skipped just like in DDU, otherwise ethernet compliant packets will be constructed."
              fw_signal="spy_gbe_skip_headers" fw_default="0b0"
              sw_units="bool"/>
        <node id="SPY_PRESCALE"        address="0x0"  mask="0xffff0000" permission="rw"
              description="Prescale factor of the spy path (0 disables the spy path, 1 allows all events to go through, and higher values will result in SPY_PRESCALE - 1 events skipped between consecutive spy events)"
              fw_signal="spy_prescale" fw_default="0x0001"/>
        <node id="SPY_DEST_MAC_1"      address="0x1"  mask="0x0000ffff" permission="rw"
              description="Destination MAC part 1 i.e. 16 bits that are sent out first"
              fw_signal="spy_gbe_dest_mac(15 downto 0)" fw_default="0xbeef"/>
        <node id="SPY_DEST_MAC_2"      address="0x1"  mask="0xffff0000" permission="rw"
              description="Destination MAC part 2 i.e. 16 bits that are sent out second"
              fw_signal="spy_gbe_dest_mac(31 downto 16)" fw_default="0xcafe"/>
        <node id="SPY_DEST_MAC_3"      address="0x2"  mask="0x0000ffff" permission="rw"
              description="Destination MAC part 3 -- 16 bits that are sent out last"
              fw_signal="spy_gbe_dest_mac(47 downto 32)" fw_default="0xaaaa"/>
        <node id="SPY_SOURCE_MAC_1"      address="0x2"  mask="0xffff0000" permission="rw"
              description="Source MAC part 1 i.e. 16 bits that are sent out first"
              fw_signal="spy_gbe_source_mac(15 downto 0)" fw_default="0xbefe"/>
        <node id="SPY_SOURCE_MAC_2"      address="0x3"  mask="0x0000ffff" permission="rw"
              description="Source MAC part 2 i.e. 16 bits that are sent out second"
              fw_signal="spy_gbe_source_mac(31 downto 16)" fw_default="0xbefe"/>
        <node id="SPY_SOURCE_MAC_3"      address="0x3"  mask="0xffff0000" permission="rw"
              description="Source MAC part 3 -- 16 bits that are sent out last"
              fw_signal="spy_gbe_source_mac(47 downto 32)" fw_default="0xbefe"/>
        <node id="SPY_ETHERTYPE"      address="0x4"  mask="0x0000ffff" permission="rw"
              description="Ethertype (should be set to jumbo)"
              fw_signal="spy_gbe_ethertype" fw_default="0x7088"/>
        <node id="MIN_PAYLOAD_SIZE"      address="0x5"  mask="0x00003fff" permission="rw"
              description="Minimum payload size in 16bit words (not including the header and trailer)"
              fw_signal="spy_min_payload_words" fw_default="0x15"/>
        <node id="MAX_PAYLOAD_SIZE"      address="0x5"  mask="0x0fffc000" permission="rw"
              description="Maximum payload size in 16bit words (not including the trailer and header)"
              fw_signal="spy_max_payload_words" fw_default="0xfff"/>
    </node>

    <node id="RUN_TYPE"       address="0x40"  mask="0x0f000000" permission="rw"
          description="User settable run type that gets embedded into the AMC header"
          fw_signal="run_type" fw_default="0x0"/>
    <node id="RUN_PARAMS"     address="0x40"  mask="0x00ffffff" permission="rw"
          description="User settable run params that gets embedded into the AMC header"
          fw_signal="run_params" fw_default="0x000000"/>
  </node>

  <node id="LAST_EVENT_FIFO"  address="0x30" description="DAQ last event fifo (read 32 bits at a time). This is only filled by DAQ when empty.">
      <node id="DISABLE"       address="0x0" mask="0x80000000" permission="rw"
            description="If set to true, then events are not written to the last event fifo. It's not needed to toggle this for data integrity reasons because this fifo is only written with one full event when it's empty, but setting this to true while reading current event could be useful if you want to know how many events you are reading exactly (because sometimes you may miss empty=true between consecutive events and read two or more events in a row)"
            fw_signal="block_last_evt_fifo" fw_default="0b0"/>
      <node id="EMPTY"       address="0x0"  mask="0x00000001" permission="r"
            description="Fifo is empty"
            fw_signal="last_evt_fifo_empty"/>
      <node id="DATA"     address="0x1"  mask="0xffffffff" permission="r"
            description="32bits of last event data"
            fw_signal="last_evt_fifo_dout" fw_read_pulse_signal="last_evt_fifo_rd_en" fw_read_ready_signal="last_evt_fifo_valid"/>
  </node>

  <node id="STATUS"  address="0x50"
        description="DAQ global status registers">
    <node id="DAQ_LINK_RDY"    address="0x0"  mask="0x00000001" permission="r"
          description="When this is 1, it means that AMC is in good communication
                       with AMC13. It must be 1 for AMC to be able to send data."
          fw_signal="daq_ready"
          sw_val_neutral="read_reg('BEFE.GEM.DAQ.CONTROL.IGNORE_DAQLINK') == 1"
          sw_val_bad="self == 0"
          sw_units="bool"/>
    <node id="DAQ_CLK_LOCKED"  address="0x0"  mask="0x00000002" permission="r"
          description="This flag is 1 if DAQ clock is locked at this moment"
          fw_signal="daq_clk_locked_i"
          sw_val_bad="self == 0"
          sw_units="bool"/>
    <node id="TTC_RDY"         address="0x0"  mask="0x00000004" permission="r"
          description="This flag is 1 if TTC clock MMCM is locked"
          fw_signal="ttc_status_i.clk_status.mmcm_locked"
          sw_val_bad="self == 0"
          sw_units="bool"/>
    <node id="DAQ_BACKPRESSURE"       address="0x0"  mask="0x00000008" permission="r"
          description="This bit comes directly from DAQLink module, indicating
                       that its internal buffers are almost full. No events will be sent
                       when this bit is 1 (though events can still be built and
                       stored in the Input and Event FIFOs)"
          fw_signal="daq_backpressure"
          sw_val_neutral="read_reg('BEFE.GEM.DAQ.CONTROL.IGNORE_DAQLINK') == 1"
          sw_val_warn="self == 1"
          sw_units="bool"/>
    <node id="DAQ_OUTPUT_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00000010" permission="r"
          description="This bit is set if DAQ output FIFO has ever been full (critical -- data loss)"
          fw_signal="err_daqfifo_full"
          sw_val_bad="self == 1"
          sw_units="bool"/>
    <node id="TTC_BC0_LOCKED"       address="0x0"  mask="0x00000020" permission="r"
          description="This bit is set if BC0 is currently locked (last BC0 arrived at the expected time)"
          fw_signal="ttc_status_i.bc0_status.locked"
          sw_val_bad="self == 0"
          sw_units="bool"/>
    <node id="L1A_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00800000" permission="r"
          description="This bit is latched whenever L1A FIFO overflow is asserted.
                       This means that one or more L1As were lost, so we are
                       out-of-sync: resync or reset is needed"
          fw_signal="err_l1afifo_full"
          sw_val_bad="self == 1"
          sw_units="bool"/>
    <node id="L1A_FIFO_IS_UNDERFLOW"       address="0x0"  mask="0x01000000" permission="r"
          description="L1A FIFO is in underflow at this moment (this bit is not latched)"
          fw_signal="l1afifo_underflow"
          sw_val_bad="self == 1"
          sw_units="bool"/>
    <node id="L1A_FIFO_IS_FULL"       address="0x0"  mask="0x02000000" permission="r"
          description="L1A FIFO is full at this moment (this bit is not latched)"
          fw_signal="l1afifo_full"
          sw_val_bad="self == 1"
          sw_units="bool"/>
    <node id="L1A_FIFO_IS_NEAR_FULL"       address="0x0"  mask="0x04000000" permission="r"
          description="This bit gets asserted when L1A FIFO gets 75% full and deasserted when it gets down to 50%"
          fw_signal="l1afifo_near_full"
          sw_val_warn="self == 1"
          sw_units="bool"/>
    <node id="L1A_FIFO_IS_EMPTY"       address="0x0"  mask="0x08000000" permission="r"
          description="L1A FIFO is empty at this moment (this bit is not latched)"
          fw_signal="l1afifo_empty"
          sw_units="bool"/>
    <node id="TTS_STATE"       address="0x0"  mask="0xf0000000" permission="r"
          description="Current TTS state (READY, BUSY, ERROR, WARN, OUT-OF-SYNC)"
          fw_signal="tts_state"
          sw_val_good="self == 8" sw_val_warn="self == 1"
          sw_enum="['DISCONNECTED', 'WARNING', 'OUT-OF-SYNC', 'UNKNOWN', 'BUSY', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'READY', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'ERROR', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN']"/>
    <node id="SPY"  address="0x10" description="Spy path control registers">
        <node id="SPY_WORD_RATE"  address="0x0"  mask="0xffffffff" permission="r"
              description="Rate of 16bit words being sent out the spy path (including ethernet frame words). If this gets close to 1Gb/s, expect overflows."
              fw_signal="spy_word_rate"
              sw_to_string="'%.2fMb/s' % ((float(self) * 16.0) / 1000000.0)"
              sw_val_good="self &lt;= 50000000"
              sw_val_warn="self &gt; 50000000"
              sw_val_bad="self &gt; 56250000"/> <!-- warn at 80%, bad at 90% (max is 1Gb/s with GbE) -->
        <node id="SPY_EVENTS_SENT"  address="0x1"  mask="0xffffffff" permission="r"
              description="Number of events sent out the spy path."
              fw_signal="spy_evt_sent"/>
        <node id="ERR_BIG_EVENT"  address="0x2"  mask="0x00000001" permission="r"
              description="This flag gets latched if the spy received an event bigger than 50000 16bit words (100KBytes). This doesn't cause any data loss by itself, but means that something wrong is going on either at the frontend or the FED (CSC events shouldn't get that big)."
              fw_signal="spy_err_evt_too_big"
              sw_val_warn="self == 1"/>
        <node id="ERR_EOE_NOT_FOUND"  address="0x2"  mask="0x00000002" permission="r"
              description="This flag gets latched if the spy doesn't find an end of event before the spy FIFO goes dry."
              fw_signal="spy_err_eoe_not_found"
              sw_val_warn="self == 1"/>
        <node id="ERR_SPY_FIFO_HAD_OFLOW"  address="0x2"  mask="0x00000004" permission="r"
              description="This flag gets latched if the spy fifo has an overflow."
              fw_signal="err_spy_fifo_ovf"
              sw_val_bad="self == 1"/>
        <node id="SPY_FIFO_AFULL_CNT"  address="0x2"  mask="0xffff0000" permission="r"
              description="Number of clocks the spy fifo spent being 75% full (full warning is set on 75% and reset at 50%)"
              fw_signal="spy_fifo_afull_cnt"
              sw_val_warn="self &gt; 100"/>
        <node id="SPY_FIFO_IS_EMPTY"  address="0x2"  mask="0x00000008" permission="r"
              description="Spy fifo is currently empty"
              fw_signal="spy_fifo_empty"/>
    </node>

    <node id="NOTINTABLE_ERR"  address="0x30"  mask="0x0000ffff" permission="r"
          description="This counter is counting DAQLink GTX/GTH not-in-table errors"
          fw_signal="daq_notintable_err_cnt"
          sw_val_neutral="read_reg('BEFE.GEM.DAQ.CONTROL.IGNORE_DAQLINK') == 1"
          sw_val_bad="self != 0"/>
    <node id="DISPER_ERR"      address="0x31"  mask="0x0000ffff" permission="r"
          description="This counter is counting DAQLink GTX/GTH dispersion errors"
          fw_signal="daq_disper_err_cnt"
          sw_val_neutral="read_reg('BEFE.GEM.DAQ.CONTROL.IGNORE_DAQLINK') == 1"
          sw_val_bad="self != 0"/>
    <node id="L1AID"           address="0x32" permission="r"
          description="Current L1A ID (similar to event number, but this may be a bit ahead of
                       that if we're still waiting for data for unprocessed L1As)"
          fw_signal="ttc_daq_cntrs_i.l1id(31 downto 0)"/>
    <node id="EVT_SENT"        address="0x33"  permission="r"
          description="Number of events shipped out to DAQLink"
          fw_signal="std_logic_vector(cnt_sent_events)"/>
    <node id="MAX_DAV_TIMER"   address="0x35"  mask="0x00ffffff" permission="r"
          description="This indicates the maximum amount of time that DAQ had
                       to wait for all inputs to report data (can be used to optimize
                       DAV timeout setting). Units = clock cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)
                       (current DAQLink clk frequency)"
          fw_signal="std_logic_vector(max_dav_timer)"
          sw_val_warn="self &gt;= 11800"/>
    <node id="LAST_DAV_TIMER"  address="0x36"  mask="0x00ffffff" permission="r"
          description="This indicates how DAQ had to wait for all inputs to report
                       data for the last event (mostly for debugging). Units = clock
                       cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)"
          fw_signal="std_logic_vector(last_dav_timer)"/>
    <node id="L1A_FIFO_DATA_CNT"  address="0x37"  mask="0x00001fff" permission="r"
          description="Current number of words in the L1A FIFO (current depth is 8192)"
          fw_signal="l1afifo_data_cnt"/>
    <node id="DAQ_FIFO_DATA_CNT"  address="0x37"  mask="0x1fff0000" permission="r"
          description="Current number of words in the DAQ output FIFO (current depth is 8192)"
          fw_signal="daqfifo_data_cnt"/>
    <node id="L1A_FIFO_NEAR_FULL_CNT"  address="0x38"  mask="0x0000ffff" permission="r"
          description="Number of clocks L1A FIFO was near-full (asserted at 75%, deasserted at 50%)"
          fw_signal="l1afifo_near_full_cnt"
          sw_val_warn="self &gt; 0"/>
    <node id="DAQ_FIFO_NEAR_FULL_CNT"  address="0x38"  mask="0xffff0000" permission="r"
          description="Number of clocks DAQ output FIFO was near-full (asserted at 75%, deasserted at 50%)"
          fw_signal="daqfifo_near_full_cnt"
          sw_val_warn="self &gt; 100"/>
    <node id="DAQ_BACKPRESSURE_CNT"  address="0x39"  mask="0x0000ffff" permission="r"
          description="Number of clocks DAQLink has asserted almost-full flag"
          fw_signal="daqlink_bp_cnt"
          sw_val_warn="self &gt; 100"/>
    <node id="TTS_WARN_CNT"  address="0x39"  mask="0xffff0000" permission="r"
          description="Number of clocks we reported TTS WARNING state"
          fw_signal="tts_warning_cnt"
          sw_val_warn="self &gt; 100"/>
    <node id="DAQ_WORD_RATE"  address="0x3a"  permission="r"
          description="Rate of 64bit words being sent out to the DAQLink in Hz (multiply by 64 to get bitrate)"
          fw_signal="daq_word_rate"
          sw_to_string="'%.2fMb/s' % ((float(self) * 64.0) / 1000000.0)"
          sw_val_good="self &lt;= 80000000"
          sw_val_warn="self &gt; 80000000"
          sw_val_bad="self &gt; 90000000"/> <!-- warn at 80%, bad at 90% (max is 6.4Gb/s with 100MHz clock that we're using) -->
  </node>

  <node id="OH${OH_IDX}"  address="0x100"
        description="Link specific registers for OH${OH_IDX}"
        generate="true" generate_size="&NUM_OHS;" generate_address_step="0x10" generate_idx_var="OH_IDX">

    <node id="CONTROL"  address="0x0">
      <node id="EOE_TIMEOUT" address="0x3"  mask="0x00ffffff" permission="rw"
            description="Units = clock cycles @ 160MHz.
                         If no new data was received in this amount of time, AMC
                         will close the current event and report it to DAQ. This is one
                         of the two ways to close an event, the other is to get new
                         data with different BX number"
            fw_signal="input_control_arr(${OH_IDX}).eb_timeout_delay" fw_default="0x000100"/>
    </node>

    <node id="STATUS"  address="0x0">
      <node id="VFAT_MIXED_EC"    mask="0x00000002" permission="r" address="0x0"
            description="There was at least one event with mixed VFAT Event IDs"
            fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_ec"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="VFAT_MIXED_BC"  mask="0x00000004" permission="r" address="0x0"
            description="There was at least one event with mixed VFAT BX IDs"
            fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_bc"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="OH_MIXED_BC"         mask="0x00000008" permission="r" address="0x0"
            description="There was at least one event with mixed OH BX IDs (OH BX
                         ID is reported for every VFAT block, but not sent to
                         AMC13)."
            fw_signal="input_status_arr(${OH_IDX}).err_mixed_oh_bc"
            sw_units="bool"
            sw_val_bad="self == 1"/>

      <node id="VFAT_TOO_MANY"      mask="0x00000010" permission="r" address="0x0"
            description="Corruption: more than 24 VFATs in event"
            fw_signal="input_status_arr(${OH_IDX}).err_event_bigger_than_24"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="VFAT_SMALL_BLOCK"   mask="0x00000020" permission="r" address="0x0"
            description="Corruption: VFAT block smaller than 192bits"
            fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_small"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="VFAT_LARGE_BLOCK"   mask="0x00000040" permission="r" address="0x0"
            description="Corruption: VFAT block bigger than 192bits"
            fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_big"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="VFAT_NO_MARKER"     mask="0x00000080" permission="r" address="0x0"
            description="Corruption: VFAT marker not detected.
                         There was at least one VFAT block not conforming to the
                         pattern of Axxx Cxxx Exxx... (see VFAT data format)
                         Note that this data will still be included in the current event
                         and sent to AMC13, but it will not be considered in
                         end-of-event detection"
            fw_signal="input_status_arr(${OH_IDX}).err_corrupted_vfat_data"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="INPUT_FIFO_HAD_OFLOW"   mask="0x00000100" permission="r" address="0x0"
            description="Critical: Input FIFO overflow occurred.
                         This bit is latched if Input FIFO was ever full when receiving
                         new data - this means data was lost.
                         TTS ERROR is asserted when this bit is 1"
            fw_signal="input_status_arr(${OH_IDX}).err_infifo_full"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="INPUT_FIFO_HAD_UFLOW"   mask="0x00000200" permission="r" address="0x0"
            description="Critical: Input FIFO underflow occurred.
                         This bit is latched if Input FIFO underflow was ever
                         detected. This means that Event FIFO indicated that there
                         should be more data than was stored in Input FIFO. This
                         might happen due to overflow or some other malfunction.
                         TTS ERROR is asserted when this bit is 1"
            fw_signal="input_status_arr(${OH_IDX}).err_infifo_underflow"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="EVENT_FIFO_HAD_OFLOW"   mask="0x00000400" permission="r" address="0x0"
            description="Critical: Event FIFO overflow occurred.
                         This bit is latched if Event FIFO was ever full when trying to
                         build a new event. This means data was lost.
                         It's not likely that this will ever be asserted because Input
                         FIFO should overflow first.
                         TTS ERROR is asserted when this bit is 1"
            fw_signal="input_status_arr(${OH_IDX}).err_evtfifo_full"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="EVT_SIZE_ERR"           mask="0x00000800" permission="r" address="0x0"
            description="Critical: Event size overflow occurred.
                         This bit is latched if there was an event containing more
                         than 4096 VFAT blocks. Input FIFO and Event FIFO will be
                         out-of-sync. This might happen if end-of-event is not
                         detected properly or for whatever reason AMC is receiving
                         a stream of VFAT blocks indicating that they belong to the
                         same event (EC/BC is the same)
                         TTS ERROR is asserted when this bit is 1"
            fw_signal="input_status_arr(${OH_IDX}).err_event_too_big"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="VFAT_INPUT_HAD_OVF"           mask="0x00010000" permission="r" address="0x0"
            description="Individual VFAT input buffer had overflow. This indicates a logic problem in the firmware and therefore is a critical error"
            fw_signal="input_status_arr(${OH_IDX}).vfat_fifo_ovf"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="VFAT_INPUT_HAD_UNF"           mask="0x00020000" permission="r" address="0x0"
            description="Individual VFAT input buffer had underflow. This indicates a logic problem in the firmware and therefore is a critical error"
            fw_signal="input_status_arr(${OH_IDX}).vfat_fifo_unf"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="TTS_STATE"           mask="0x0000f000" permission="r" address="0x0"
            description="Input TTS state (gets integrated into global TTS state later)"
            fw_signal="input_status_arr(${OH_IDX}).tts_state"
            sw_val_neutral="(read_reg('BEFE.GEM.DAQ.CONTROL.INPUT_ENABLE_MASK') >> ${OH_IDX}) &amp; 1 == 0"
            sw_val_good="self == 8" sw_val_warn="self == 1"
            sw_enum="['DISCONNECTED', 'WARNING', 'OUT-OF-SYNC', 'UNKNOWN', 'BUSY', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'READY', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'ERROR', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN']"/>
      <node id="INPUT_FIFO_IS_UFLOW"    mask="0x01000000" permission="r" address="0x0"
            description="Current status: Input FIFO is in underflow"
            fw_signal="input_status_arr(${OH_IDX}).infifo_underflow"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="INPUT_FIFO_IS_FULL"     mask="0x02000000" permission="r" address="0x0"
            description="Current status: Input FIFO is full"
            fw_signal="input_status_arr(${OH_IDX}).infifo_full"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="INPUT_FIFO_IS_AFULL"    mask="0x04000000" permission="r" address="0x0"
            description="Current status: Input FIFO is near-full (asserted at 75% and deasserted at 50%)"
            fw_signal="input_status_arr(${OH_IDX}).infifo_near_full"
            sw_units="bool"
            sw_val_warn="self == 1"/>
      <node id="INPUT_FIFO_IS_EMPTY"    mask="0x08000000" permission="r" address="0x0"
            description="Current status: Input FIFO is empty"
            fw_signal="input_status_arr(${OH_IDX}).infifo_empty"
            sw_units="bool"/>
      <node id="EVENT_FIFO_IS_UFLOW"    mask="0x10000000" permission="r" address="0x0"
            description="Current status: Event FIFO is in underflow"
            fw_signal="input_status_arr(${OH_IDX}).evtfifo_underflow"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="EVENT_FIFO_IS_FULL"     mask="0x20000000" permission="r" address="0x0"
            description="Current status: Event FIFO is full"
            fw_signal="input_status_arr(${OH_IDX}).evtfifo_full"
            sw_units="bool"
            sw_val_bad="self == 1"/>
      <node id="EVENT_FIFO_IS_AFULL"    mask="0x40000000" permission="r" address="0x0"
            description="Current status: Event FIFO is near-full (asserted at 75% and deasserted at 50%)"
            fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full"
            sw_units="bool"
            sw_val_warn="self == 1"/>
      <node id="EVENT_FIFO_IS_EMPTY"    mask="0x80000000" permission="r" address="0x0"
            description="Current status: Event FIFO is empty"
            fw_signal="input_status_arr(${OH_IDX}).evtfifo_empty"
            sw_units="bool"/>
    </node>

    <node id="COUNTERS" address="0x0">
      <node id="CORRUPT_VFAT_BLK_CNT"  address="0x1" permission="r"
            description="This counter is incremented when a VFAT block does not
                         conform to the pattern of Axxx Cxxx Exxx... (see VFAT
                         data format)
                         Note that this data is still included in events and sent to
                         AMC13, but it does not participate in end-of-event
                         detection."
            fw_signal="input_status_arr(${OH_IDX}).cnt_corrupted_vfat"
            sw_val_bad="self != 0"/>
      <node id="EVN"                   address="0x2" mask="0x00ffffff" permission="r"
            description="Current event number of the event builder.
                         This counter starts at 1 and increments with each
                         end-of-event detection. This number should be similar to
                         the number of events sent to AMC13 in normal operation,
                         but it might not always be exactly the same because there's
                         some latency between building an event and sending it. In
                         addition, event sending could stop due to DAQ FIFO being
                         almost full or DAQLink not being ready."
            fw_signal="input_status_arr(${OH_IDX}).eb_event_num"
            sw_val_neutral="(read_reg('BEFE.GEM.DAQ.CONTROL.INPUT_ENABLE_MASK') >> ${OH_IDX}) &amp; 1 == 0"
            sw_val_good="self &lt;= read_reg('BEFE.GEM.DAQ.STATUS.L1AID') &lt; self + 100"
            sw_val_warn="read_reg('BEFE.GEM.DAQ.STATUS.L1AID') >= self + 100"/>
      <node id="INPUT_FIFO_DATA_CNT"  address="0x4"  mask="0x00000fff" permission="r"
            description="Current number of words in the Input FIFO (current depth is 4096)"
            fw_signal="chamber_infifos(${OH_IDX}).data_cnt"/>
      <node id="EVT_FIFO_DATA_CNT"  address="0x4"  mask="0x0fff0000" permission="r"
            description="Current number of words in the Event FIFO (current depth is 4096)"
            fw_signal="chamber_evtfifos(${OH_IDX}).data_cnt"/>
      <node id="INPUT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0x0000ffff" permission="r"
            description="Number of times Input FIFO was near-full (asserted at 75%, deasserted at 50%)"
            fw_signal="input_status_arr(${OH_IDX}).infifo_near_full_cnt"
            sw_val_neutral="(read_reg('BEFE.GEM.DAQ.CONTROL.INPUT_ENABLE_MASK') >> ${OH_IDX}) &amp; 1 == 0"
            sw_val_warn="self > 100"/>
      <node id="EVT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0xffff0000" permission="r"
            description="Number of times Event FIFO was near-full (asserted at 75%, deasserted at 50%)"
            fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full_cnt"
            sw_val_neutral="(read_reg('BEFE.GEM.DAQ.CONTROL.INPUT_ENABLE_MASK') >> ${OH_IDX}) &amp; 1 == 0"
            sw_val_warn="self > 100"/>
      <node id="VFAT_BLOCK_RATE"  address="0x6"  mask="0x00007fff" permission="r"
            description="Rate of VFAT blocks (192bit words) being written to Input FIFO in Hz (multiply by 192 to get bitrate)"
            fw_signal="input_status_arr(${OH_IDX}).infifo_wr_rate"
            sw_to_string="'%.2fMb/s' % ((float(self) * 192.0) / 1000000.0)"
            sw_val_neutral="(read_reg('BEFE.GEM.DAQ.CONTROL.INPUT_ENABLE_MASK') >> ${OH_IDX}) &amp; 1 == 0"
            sw_val_good="self &lt;= 1333333"
            sw_val_warn="self &gt; 1333333"
            sw_val_bad="self &gt; 1500000"/> <!-- warn at 80%, bad at 90% (max is 320Mb/s) -->
      <node id="EVT_RATE"  address="0x6"  mask="0xffff8000" permission="r"
            description="Rate of events being written to Event FIFO in Hz"
            fw_signal="input_status_arr(${OH_IDX}).evtfifo_wr_rate"/>
      <node id="MAX_EOE_TIMER"         address="0x7" mask="0x00ffffff" permission="r"
            description="Units = clock cycles @ 160MHz.
                         This indicates the maximum amount of time that event
                         builder took to build and close the event. Note: this is
                         mostly for debugging, most of the time it should be equal
                         to 'End of event timeout'"
            fw_signal="input_status_arr(${OH_IDX}).eb_max_timer"/>
      <node id="LAST_EOE_TIMER"        address="0x8" mask="0x00ffffff" permission="r"
            description="Units = clock cycles @ 160MHz.
                         This shows how long event builder took to build and close
                         the last event. Note: this is mostly for debugging, but could
                         be used to tune the 'end of event timeout'"
            fw_signal="input_status_arr(${OH_IDX}).eb_last_timer"/>
    </node>

  </node>
</node>

<!-- OH link module -->
<node id="OH_LINKS"  address="0x00600000"
      description="OH Link monitoring registers"
      fw_is_module="true"
      fw_module_file="../gem/hdl/oh/oh_link_regs.vhd"
      fw_user_clock_signal="clk_i"
      fw_bus_clock_signal="ipb_clk_i"
      fw_bus_reset_signal="ipb_reset_i"
      fw_master_bus_signal="ipb_mosi_i"
      fw_slave_bus_signal="ipb_miso_o"
      fw_reg_addr_msb="12"
      fw_reg_addr_lsb="0">

  <node id="OH${OH_IDX}" address="0x100"
        description="Links for OH ${OH_IDX}"
        generate="true" generate_size="&NUM_OHS;" generate_address_step="0x100" generate_idx_var="OH_IDX">

    <node id="GBT${GBT}_READY" address="0x0" mask="0x00000001" permission="r"
          description="If this is set to 1 it means that the backend is receiving valid GBT frames from this GBT link"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_ready"
          sw_val_bad="self == 0" sw_enum="['NOT_READY', 'READY']"/>

    <node id="GBT${GBT}_WAS_NOT_READY" address="0x0" mask="0x00000002" permission="r"
          description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_had_not_ready"
          sw_val_warn="self == 1"/>

    <node id="GBT${GBT}_RX_HAD_OVERFLOW" address="0x0" mask="0x00000004" permission="r"
          description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_sync_status.had_ovf"
          sw_val_bad="self == 1"/>

    <node id="GBT${GBT}_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000008" permission="r"
          description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_sync_status.had_unf"
          sw_val_bad="self == 1"/>

    <node id="GBT${GBT}_FEC_ERR_CNT" address="0x0" mask="0x00000ff0" permission="r"
          description="Number of FEC errors corrected by the GBT decoder"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_correction_cnt"
          sw_val_warn="self > 0"/>

    <node id="GBT${GBT}_TX_PHASE" address="0x0" mask="0x0007f000" permission="rw"
          description="This register sets the number of bitslips to use on the GBT TX frame, which in turn determines the 40MHz clock phase on the GBTX chip. Valid values: 0-119."
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_tx_bitslip_arr(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT})" fw_default="0b0000000"/>

    <node id="GBT${GBT}_RX_HEADER_HAD_UNLOCK" address="0x0" mask="0x00080000" permission="r"
          description="This flag is latched high if the GBT RX header lock has been lost, and is reset with link reset"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_header_had_unlock"
          sw_val_bad="self == 1"/>

    <node id="GBT${GBT}_RX_NUM_BITSLIPS" address="0x0" mask="0x0ff00000" permission="r"
          description="Number of bitslips done on the RX data before achieving header lock"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_rx_num_bitslips"/>

    <node id="GBT${GBT}_TX_READY" address="0x0" mask="0x10000000" permission="r"
          description="This is set to 1 when the GBT TX core is ready (gearbox is aligned)"
          generate="true" generate_size="&NUM_GBTS_PER_OH;" generate_address_step="0x1" generate_idx_var="GBT"
          fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + ${GBT}).gbt_tx_ready"
          sw_monitor_error_value="0"
          sw_val_bad="self == 0"/>

    <node id="VFAT_MASK" address="0x8" mask="0x00ffffff" permission="rw"
          description="Mask the RX link of the selected VFATs (both slow control and DAQ path will be shut off for these VFATs)."
          fw_signal="vfat_mask_arr(${OH_IDX})" fw_default="0x000000"/>

    <node id="VFAT${VFAT_IDX}" address="0x10"
          description="Link status of VFAT ${VFAT_IDX} on ${OH_IDX}"
          generate="true" generate_size="&NUM_VFATS_PER_OH;" generate_address_step="0x2" generate_idx_var="VFAT_IDX">

      <node id="LINK_GOOD" address="0x0" mask="0x00000001" permission="r"
            description="This flag is set high after detecting 10 consecutive good sync verify replies and set bad after 100 bad ones in a row (sync verify is done once per orbit). This flag can only go high if the initial sync procedure and RX bitslipping was done successfully"
            fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).sync_good"
            sw_val_bad="self == 0"/>
      <node id="SYNC_ERR_CNT" address="0x0" mask="0x000000f0" permission="r"
            description="This counter counts the total number of times that VFAT3 didn't reply to sync_verify command correctly. This counter doesn't roll over, and is reset on link reset."
            fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).sync_error_cnt"
            sw_val_warn="self > 0"/>
      <node id="DAQ_EVENT_CNT" address="0x0" mask="0x00ffff00" permission="r"
            description="This counter counts the number of DAQ events received from this VFAT (note that this is an 8bit rolling counter)"
            fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).daq_event_cnt"/>
      <node id="DAQ_CRC_ERROR_CNT" address="0x0" mask="0xff000000" permission="r"
            description="This counter counts the number of CRC errors in the DAQ events received from this VFAT (this counter stops at max value)"
            fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).daq_crc_err_cnt"
            sw_val_warn="self > 0"/>

    </node>

  </node>

  <node id="SPY" address="0xa" description="Spy readout link">
      <node id="MGT_BUF_OVF_CNT" address="0x0" mask="0x0000ffff" permission="r"
            description="Number of times that MGT elastic buffer has been in overflow"
            fw_signal="spy_mgt_buf_ovf_sync"
            sw_monitor_warn_min_threshold="1"/>
      <node id="MGT_BUF_UNF_CNT" address="0x0" mask="0xffff0000" permission="r"
            description="Number of times that MGT elastic buffer has been in underflow"
            fw_signal="spy_mgt_buf_unf_sync"
            sw_monitor_warn_min_threshold="1"/>
      <node id="CLK_CORR_ADD_CNT" address="0x1" mask="0x0000ffff" permission="r"
            description="Number of times that MGT has added a fake idle word to correct for clock drift"
            fw_signal="spy_clk_corr_add_sync"/>
      <node id="CLK_CORR_DROP_CNT" address="0x1" mask="0xffff0000" permission="r"
            description="Number of times that MGT has dropped an idle word to correct for clock drift"
            fw_signal="spy_clk_corr_drop_sync"/>
      <node id="NOT_IN_TABLE_CNT" address="0x2" mask="0x0000ffff" permission="r"
            description="Number of not-in-table errors"
            fw_signal="spy_not_in_table_sync"
            sw_monitor_warn_min_threshold="1000"/>
      <node id="DISPERR_CNT" address="0x2" mask="0xffff0000" permission="r"
            description="Number of disparity errors"
            fw_signal="spy_disperr_sync"
            sw_monitor_warn_min_threshold="1000"/>
  </node>

</node>

<!--GEM slow control module -->
<node id="SLOW_CONTROL"  address="0x00B00000"
      description="This module is handling slow control (mainly OH SCA and OH GBTx IC related communication)"
      fw_is_module="true"
      fw_module_file="../gem/hdl/slow_control/slow_control.vhd"
      fw_user_clock_signal="ttc_clk_i.clk_40"
      fw_bus_clock_signal="ipb_clk_i"
      fw_bus_reset_signal="ipb_reset_i"
      fw_master_bus_signal="ipb_mosi_i"
      fw_slave_bus_signal="ipb_miso_o"
      fw_reg_addr_msb="16"
      fw_reg_addr_lsb="0">

  <node id="SCA" address="0x0">
    <node id="CTRL" address="0x0">
      <node id="MODULE_RESET" address="0x0" permission="w"
            description="SCA controller reset (coming out of module reset it will also reset and reconfigure the SCA chip)"
            fw_write_pulse_signal="sca_reset"/>
      <node id="OH_FPGA_HARD_RESET" address="0x1" permission="w"
            description="Writing to this register will trigger OH FPGA hard reset"
            fw_write_pulse_signal="manual_hard_reset"/>
      <node id="TTC_HARD_RESET_EN" address="0x2" permission="rw"
            description="This is a bitmask (one bit per OH) that determines whether or not TTC hard reset commands are forwarded to the SCA to reset the OH FPGA (Nth bit set to 1 will enable TTC hard resets to the Nth OH)"
            fw_signal="sca_ttc_hr_enable" fw_default="0xffffffff"/>
      <node id="SCA_RESET_ENABLE_MASK" address="0x3" mask="0xffffffff" permission="rw"
            description="This bitmask defines which SCAs will be reset uppon receipt of MODULE_RESET command."
            fw_signal="sca_reset_mask" fw_default="0xffffffff"/>
    </node>

    <node id="STATUS" address="0x100">
      <node id="READY" address="0x0" mask="0xffffffff" permission="r"
            description="Bits in this register indicate that the SCA controller for the corresponding link has good communication with the SCA chip"
            fw_signal="sca_ready_arr"/>
      <node id="CRITICAL_ERROR" address="0x1" mask="0xffffffff" permission="r"
            description="Bits in this register indicate that the SCA controller for the corresponding link has encountered a critical error (needs reset)"
            fw_signal="sca_critical_error_arr"/>
      <node id="NOT_READY_CNT_OH${OH_IDX}" address="0x2" mask="0x0000ffff" permission="r"
            description="Counts the number of times that the SCA controller READY signal went to 0 since last SCA reset"
            generate="true" generate_size="&NUM_OHS;" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
            fw_signal="sca_not_ready_cnt_arr(${OH_IDX})"/>

      <!--node id="RX_ERR_CNT" address="0x1" mask="0x0000ffff" permission="r"
            description="Number of RX errors"
            fw_signal="sca_rx_err_cnt"/>
      <node id="SEQ_NUM_ERR_CNT" address="0x1" mask="0xffff0000" permission="r"
            description="Number of sequence number errors"
            fw_signal="sca_seq_num_err_cnt"/>
      <node id="CRC_ERR_CNT" address="0x2" mask="0x0000ffff" permission="r"
            description="Number of CRC errors"
            fw_signal="sca_crc_err_cnt"/>
      <node id="TRANSACTION_TIMEOUT_CNT" address="0x2" mask="0xffff0000" permission="r"
            description="Number of transaction timeouts"
            fw_signal="sca_tr_timeout_cnt"/>
      <node id="TRANSACTION_FAIL_CNT" address="0x3" mask="0x0000ffff" permission="r"
            description="Number of transaction failures (all retries used up)"
            fw_signal="sca_tr_fail_cnt"/>
      <node id="LAST_SCA_ERROR" address="0x3" mask="0x007f0000" permission="r"
            description="Last error reported by the SCA chip"
            fw_signal="sca_last_sca_error"/>
      <node id="TRANSACTION_DONE_CNT" address="0x4" permission="r"
            description="Number of transactions successfully executed"
            fw_signal="sca_tr_done_cnt"/-->
    </node>

    <node id="MANUAL_CONTROL" address="0x1000">
      <node id="LINK_ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
            description="This is a bitmask of enabled links for the SCA manual command.
                         Multiple channels can be enabled at the same time, which will
                         result in a broadcast command to these channels when writing to the command registers"
            fw_signal="sca_user_command_en_mask" fw_default="0x00000000"/>

      <node id="SCA_CMD" address="0x1">
        <node id="SCA_CMD_CHANNEL" address="0x0" mask="0x000000ff" permission="rw"
              description="Manual SCA command: channel"
              fw_signal="sca_user_command.channel" fw_default="0x00"/>
        <node id="SCA_CMD_COMMAND" address="0x0" mask="0x0000ff00" permission="rw"
              description="Manual SCA command: command"
              fw_signal="sca_user_command.command" fw_default="0x00"/>
        <node id="SCA_CMD_LENGTH" address="0x0" mask="0x00ff0000" permission="rw"
              description="Manual SCA command: length (range = 0 to 4)"
              fw_signal="sca_user_command.length" fw_default="0x00"/>
        <node id="SCA_CMD_DATA" address="0x1" permission="rw"
              description="Manual SCA command: data"
              fw_signal="sca_user_command.data" fw_default="0x00000000"/>
        <node id="SCA_CMD_EXECUTE" address="0x2" permission="w"
              description="Manual SCA command: writing to this register will trigger the execution of the SCA command"
              fw_write_pulse_signal="sca_user_command_en" fw_write_done_signal="sca_user_command_done_all"/>
      </node>

      <node id="SCA_REPLY_OH${OH_IDX}" address="0x4"
            description="SCA reply for Optohybrid ${OH_IDX}"
            generate="true" generate_size="&NUM_OHS;" generate_address_step="0x00000002" generate_idx_var="OH_IDX">

        <node id="SCA_RPY_CHANNEL" address="0x0" mask="0x000000ff" permission="r"
              description="SCA reply to the manual command: channel"
              fw_signal="sca_user_reply_arr(${OH_IDX}).channel"/>
        <node id="SCA_RPY_ERROR" address="0x0" mask="0x0000ff00" permission="r"
              description="SCA reply to the manual command: command"
              fw_signal="sca_user_reply_arr(${OH_IDX}).error"/>
        <node id="SCA_RPY_LENGTH" address="0x0" mask="0x00ff0000" permission="r"
              description="SCA reply to the manual command: length (range = 0 to 4)"
              fw_signal="sca_user_reply_arr(${OH_IDX}).length"/>
        <node id="SCA_RPY_DATA" address="0x1" permission="r"
              description="SCA reply to the manual command: data"
              fw_signal="sca_user_reply_arr(${OH_IDX}).data"/>
      </node>
    </node>

    <node id="JTAG" address="0x2500">
      <node id="CTRL" address="0x0">
        <node id="ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
              description="This is a bitmask of enabled links for the SCA JTAG commands.
                           Multiple channels can be enabled at the same time, which will
                           result in a broadcast command to these channels when writing to the TDO and TMS registers"
              fw_signal="jtag_enabled_mask" fw_default="0x00000000"/>
        <node id="SHIFT_MSB" address="0x1" mask="0x00000002" permission="rw"
              description="If this is 1 then SCA will shift out bits MSB to LSB and if this is 0 then LSB to MSB (default)"
              fw_signal="jtag_shift_msb_first" fw_default="0b0"/>
        <node id="EXPERT" address="0x1">
          <node id="EXEC_ON_EVERY_TDO" address="0x0" mask="0x00000004" permission="rw"
                description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will execute
                             JTAG_GO after every TDO shift (even if length is higher than 32)"
                fw_signal="jtag_exec_on_every_tdo" fw_default="0b0"/>
          <node id="NO_SCA_LENGTH_UPDATE" address="0x0" mask="0x00000008" permission="rw"
                description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will
                             assume that SCA already has the correct length and will not update it before each JTAG_GO"
                fw_signal="jtag_no_length_update" fw_default="0b0"/>
          <node id="SHIFT_TDO_ASYNC" address="0x0" mask="0x00000010" permission="rw"
                description="kindof expert: if this is set high then JTAG controller will acknowledge the TDO shift
                             command immediately, but if the second command is received while it's still busy it
                             won't assert jtag_shift_done_o until the previous command is done"
                fw_signal="jtag_shift_tdo_async" fw_default="0b0"/>
        </node>
      </node>
      <node id="NUM_BITS" address="0x2" mask="0x000007f" permission="rw"
            description="Number of bits in the JTAG command (0 means 128). Once you shift this number of bits of
                         TDO data, the JTAG command will be executed and TDI is available for reading"
            fw_signal="jtag_cmd_length" fw_default="0b0000000"/>
      <node id="TMS" address="0x3" permission="w"
            description="TMS bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                         The write transaction completes once the bit shifting to the SCA is already done and
                         confirmed by the SCA, so there's no need to sleep between the consecutive writes to this register."
            fw_signal="jtag_tms" fw_write_pulse_signal="jtag_shift_tms_en" fw_write_done_signal="jtag_shift_done_all"
            fw_default="0x00000000"/>
      <node id="TDO" address="0x4" permission="w"
            description="TDO bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                         Once the number of bits shifted is equal to or greater than the NUM_BITS the JTAG command
                         will be executed. The write transaction completes once the bit shifting to the SCA is
                         already done and confirmed by the SCA, so there's no need to sleep between the consecutive
                         writes to this register."
            fw_signal="jtag_tdo" fw_write_pulse_signal="jtag_shift_tdo_en" fw_write_done_signal="jtag_shift_done_all"
            fw_default="0x00000000"/>

      <node id="TDI_OH${OH_IDX}" address="0x5" permission="r"
            description="When reading this register the TDI bits are shifted from the SCA of OH${OH_IDX} (32 bits with each read)."
            generate="true" generate_size="&NUM_OHS;" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
            fw_signal="jtag_tdi_arr(${OH_IDX})" fw_read_pulse_signal="jtag_shift_tdi_en_arr(${OH_IDX})" fw_read_ready_signal="jtag_shift_done_arr(${OH_IDX})"/>
    </node>

    <!--node id="DEBUG" address="0x3000">
      <node id="RAW_TX_LAST_CMD_0" address="0x0" permission="r"
            description="Last raw output on the TX, bits [31:0]"
            fw_signal="sca_tx_raw_last_cmd(31 downto 0)"/>
      <node id="RAW_TX_LAST_CMD_1" address="0x1" permission="r"
            description="Last raw output on the TX, bits [63:32]"
            fw_signal="sca_tx_raw_last_cmd(63 downto 32)"/>
      <node id="RAW_TX_LAST_CMD_2" address="0x2" permission="r"
            description="Last raw output on the TX, bits [95:64]"
            fw_signal="sca_tx_raw_last_cmd(95 downto 64)"/>
      <node id="RAW_RX_LAST_RPY_0" address="0x3" permission="r"
            description="Last raw input on the RX, bits [31:0]"
            fw_signal="sca_rx_raw_last_reply(31 downto 0)"/>
      <node id="RAW_RX_LAST_RPY_1" address="0x4" permission="r"
            description="Last raw input on the RX, bits [63:32]"
            fw_signal="sca_rx_raw_last_reply(63 downto 32)"/>
      <node id="RAW_RX_LAST_RPY_2" address="0x5" permission="r"
            description="Last raw input on the RX, bits [95:64]"
            fw_signal="sca_rx_raw_last_reply(95 downto 64)"/>
      <node id="RX_LAST_CALC_CRC" address="0x6" mask="0x0000ffff" permission="r"
            description="RX last calculated CRC"
            fw_signal="sca_rx_last_calc_crc"/>
    </node-->

  </node>

  <node id="IC" address="0x3000">
    <node id="ADDRESS" address="0x0" mask="0x0000ffff" permission="rw"
          description="GBTx register address to read or write"
          fw_signal="ic_rw_address" fw_default="0x0000"/>
    <node id="READ_WRITE_LENGTH" address="0x1" mask="0x00000007" permission="rw"
          description="Number of data bytes to be written or read e.g. if you set it to 4 then 4 consecutive
                       GBTx registers will be written with the 4 bytes in WRITE_DATA register. Max is 4."
          fw_signal="ic_rw_length" fw_default="0x01"/>
    <node id="WRITE_DATA" address="0x2" permission="rw"
          description="GBTx register value to write"
          fw_signal="ic_write_data" fw_default="0x00"/>
    <node id="EXECUTE_WRITE" address="0x3" permission="w"
          description="writing any value here will execute a GBTx register write operation"
          fw_write_pulse_signal="ic_write_req" fw_write_done_signal="ic_write_req_done"/>
    <node id="EXECUTE_READ" address="0x4" permission="w"
          description="writing any value here will execute a GBTx register read operation"
          fw_write_pulse_signal="ic_read_req" fw_write_done_signal="ic_read_req_done"/>
    <node id="GBT_I2C_ADDR" address="0x5" mask="0x0000007f" permission="rw"
          description="GBTx/lpGBT I2C address of the chip to communicate with, as defined by the external pins (or internal registers) of the chip"
          fw_signal="ic_gbt_i2c_addr" fw_default="0b0000001"/>
    <node id="GBT_LINK_SELECT" address="0x6" mask="0x0000003f" permission="rw"
          description="Selects the GBT link to use"
          fw_signal="ic_link_select" fw_default="0b000000"/>
    <node id="READ_DATA" address="0x7" permission="r"
          description="GBTx register value to read"
          fw_signal="ic_read_data" fw_read_ready_signal="ic_read_data_valid"/>
    <node id="GBT_FRAME_FORMAT" address="0x8" mask ="0x00000003" permission="rw"
          description="Frame format to use to communicate with the GBTx/lpGBT ASIC"
          fw_signal="ic_gbt_frame_format" fw_default="0b00"
          sw_enum="['GBTX', 'LPGBT_V0', 'LPGBT_V1']"/>
    <node id="READ_STATUS" address="0x10">
      <node id="READ_DONE" address="0x0" mask="0x00000001" permission="r"
          description="Set to '1' when the IC read/write transaction is complete (reset for every execute)"
          fw_signal="ic_read_stat(0)"/>
      <node id="UPLINK_PARITY" address="0x0" mask="0x00000002" permission="r"
          description="Set to '1' if uplink (from the GBT to the counting room) parity check passes"
          fw_signal="ic_read_stat(2)"/>
      <node id="DOWNLINK_PARITY" address="0x0" mask="0x00000004" permission="r"
          description="Set to '1' if downlink (from the counting room to the GBT) parity check passes"
          fw_signal="ic_read_stat(3)"/>
      <node id="GBT_I2C_ADDR" address="0x0" mask="0x00000008" permission="r"
          description="Set to '1' if GBT I2C chip address received matches value written"
          fw_signal="ic_read_stat(4)"/>
      <node id="READ_WRITE_LENGTH" address="0x0" mask="0x00000010" permission="r"
          description="Set to '1' if number of data words received matches rw length chosen"
          fw_signal="ic_read_stat(5)"/>
      <node id="ADDRESS" address="0x0" mask="0x00000020" permission="r"
          description="Set to '1' if register address received matches address sent"
          fw_signal="ic_read_stat(6)"/>
    </node>
  </node>

  <node id="VFAT3" address="0x4000">
    <node id="CRC_ERROR_CNT" address="0x0" mask="0x0000ffff" permission="r"
          description="Number of CRC errors in the VFAT3 slow control reply packets"
          fw_signal="vfat3_sc_status_i.crc_error_cnt"/>
    <node id="PACKET_ERROR_CNT" address="0x0" mask="0xffff0000" permission="r"
          description="Number of packet errors in the VFAT3 slow control reply packets. Packet error means that either a received packet was too long, or a packet with good CRC was received but the contents were not as expected, more specifically one or more of the following fields were not correct: transaction ID, HDLC address, HDLC control, IPBus version, IPBus write flag."
          fw_signal="vfat3_sc_status_i.packet_error_cnt"/>
    <node id="BITSTUFFING_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r"
          description="Number of bitstuffing errors in the VFAT3 slow control reply packets. Bitstuffing error means that more than 5 SC1 characters were received in a row and it was not a frame separator (frame separator is 01111110)."
          fw_signal="vfat3_sc_status_i.bitstuff_error_cnt"/>
    <node id="TIMEOUT_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r"
          description="Number of timeouts while waiting for a slow control reply from a VFAT3."
          fw_signal="vfat3_sc_status_i.timeout_error_cnt"/>
    <node id="AXI_STROBE_ERROR_CNT" address="0x2" mask="0x0000ffff" permission="r"
          description="Number of AXI strobe errors in VFAT3 slow control transactions. An AXI strobe error means that the AXI strobe went away before the VFAT3 slow control state machine replied or timed out. This might be caused by force closing the AXI transaction upstream e.g. a safety timeout in Zynq AXI master."
          fw_signal="vfat3_sc_status_i.axi_strobe_error_cnt"/>
    <node id="TRANSACTION_CNT" address="0x2" mask="0xffff0000" permission="r"
          description="Total number of VFAT3 transactions done so far. This counter rolls over."
          fw_signal="vfat3_sc_status_i.transaction_cnt"/>
  </node>

</node>

<!--OptoHybrid module -->
<node id="OH"  address="0x00400000"
      description="Optohybrid Registers"
      fw_is_module="true"
      fw_is_module_external="true">

  <node id="OH${OH_IDX}"  address="0x0"
        description="Optohybrid ${OH_IDX}"
        generate="true" generate_size="&NUM_OHS;" generate_address_step="0x00010000" generate_idx_var="OH_IDX">

        <!--Insert here the OH FPGA module -->
        <xi:include href="optohybrid_registers.xml"/>

    <node id="GEB"  address="0x100000"
          description="VFAT3 registers">

        <node id="VFAT${VFAT_IDX}"  address="0x0"
              description="VFAT ${VFAT_IDX}"
              generate="true" generate_size="&NUM_VFATS_PER_OH;" generate_address_step="0x00000800" generate_idx_var="VFAT_IDX">

          <node id="VFAT_CHANNELS"  address="0x0"
                description="Registers for the individual VFAT channels
                             Hardwired sleep value 0x00
                             Software default value 0x00">
            <node id="CHANNEL${CHANNEL_IDX}"  address="0x00"  permission="rw"
                  description="Config register for VFAT channel ${CHANNEL_IDX}"
                  generate="true" generate_size="128" generate_address_step="0x1" generate_idx_var="CHANNEL_IDX">

              <node id="CALPULSE_ENABLE"  address="0x0" mask="0x00008000"  permission="rw"
                    description="Enable the calibration pulse to the channel input"/>
              <node id="MASK"  address="0x0" mask="0x00004000"  permission="rw"
                    description="Mask the channel output for trigger and readout"/>
              <node id="ZCC_TRIM_POLARITY"  address="0x0" mask="0x00002000"  permission="rw"
                    description="Zero Crossing Comparator threshold trimming: correction polarity (0 = positive, 1 = negative)"/>
              <node id="ZCC_TRIM_AMPLITUDE"  address="0x0" mask="0x00001f80"  permission="rw"
                    description="Zero Crossing Comparator threshold trimming: correction amplitude (steps of 0.5mV)"/>
              <node id="ARM_TRIM_POLARITY"  address="0x0" mask="0x00000040"  permission="rw"
                    description="Arming Comparator threshold trimming: correction polarity (0 = positive, 1 = negative)"/>
              <node id="ARM_TRIM_AMPLITUDE"  address="0x0" mask="0x0000003f"  permission="rw"
                    description="Arming Comparator threshold trimming: correction amplitude (steps of 0.5mV)"/>

            </node>
          </node> <!-- end of VFATChannels -->

          <!-- a catch-all for all config registers (individual bits are extracted below), may want to use these registers for faster configuration to set all 32 bits at once instead of individual pieces -->
          <node id="CFG_${CFG_REG_IDX}"  address="0x81"  permission="rw"
                description="VFAT control register number ${CFG_REG_IDX}"
                generate="true" generate_size="17" generate_address_step="0x1" generate_idx_var="CFG_REG_IDX"/>
          <!-- -->

          <node id="CFG_PULSE_STRETCH"  address="0x81" mask="0x0000e000"  permission="rw"
                description="Pulse Stretcher control. Range is from 1 to 8 clock cycles (0 means 1 cycle, 7 means 8 cycles)"/>
          <node id="CFG_SYNC_LEVEL_MODE"  address="0x81" mask="0x00000004"  permission="rw"
                description="Switch the input synchronizer from edge to level mode (0 = edge, 1 = level)"/>
          <node id="CFG_SELF_TRIGGER_MODE"  address="0x81" mask="0x00000002"  permission="rw"
                description="Enable self trigger mode (0 = disable, 1 = enable)"/>
          <node id="CFG_DDR_TRIGGER_MODE"  address="0x81" mask="0x00000001"  permission="rw"
                description="Enable DDR trigger output mode (0 = SDR, 1 = DDR)"/>

          <node id="CFG_SPZS_SUMMARY_ONLY"  address="0x82" mask="0x00008000"  permission="rw"
                description="When set high, the SPZS mode will send only the 16bit partition summary (no sub-partition data at all)"/>
          <node id="CFG_SPZS_MAX_PARTITIONS"  address="0x82" mask="0x00003c00"  permission="rw"
                description="Maximum number of sub-partition data to send in SPZS mode (range: 1-16)"/>
          <node id="CFG_SPZS_ENABLE"  address="0x82" mask="0x00000100"  permission="rw"
                description="Enable SPZS zero suppression mode"/>
          <node id="CFG_SZP_ENABLE"  address="0x82" mask="0x00000080"  permission="rw"
                description="Enable SZP zero suppression mode (suppress zero packets -- only send the header)"/>
          <node id="CFG_SZD_ENABLE"  address="0x82" mask="0x00000040"  permission="rw"
                description="Enable SZD zero suppression mode (suppress zero data only -- still send header, EC, BC and CRC)"/>
          <node id="CFG_TIME_TAG"  address="0x82" mask="0x00000030"  permission="rw"
                description="Time tag format (00 = EC and BC, 01 = EC, 10 = BC, 11 = EC+BC)"/>
          <node id="CFG_EC_BYTES"  address="0x82" mask="0x00000006"  permission="rw"
                description="Event counter bytes (00 = 1B, 01 = 2B, 10 = 3B, 11 = 1B)"/>
          <node id="CFG_BC_BYTES"  address="0x82" mask="0x00000001"  permission="rw"
                description="Bunch counter bytes (0 = 2B, 1 = 3B)"/>
          <node id="CFG_FP_FE"  address="0x83" mask="0x000000e0"  permission="rw"
                description="Front end peaking time (000 = 25ns, 001 = 50ns, 011 = 75ns, 111 = 100ns)"/>
          <node id="CFG_RES_PRE"  address="0x83" mask="0x0000001c"  permission="rw"
                description="Preamplifier resistance set (001 = high gain, 010 = middle gain, 100 = low gain)"/>
          <node id="CFG_CAP_PRE"  address="0x83" mask="0x00000003"  permission="rw"
                description="Preamplifier capacity set (00 = high gain, 01 = middle gain, 11 = low gain)"/>
          <node id="CFG_PT"  address="0x84" mask="0x000003c0"  permission="rw"
                description="CFD Time Constant (0001 = 25ns, 0011 = 50ns, 0111 = 75ns, 1111 = 100ns)"/>
          <node id="CFG_EN_HYST"  address="0x84" mask="0x00000020"  permission="rw"
                description="Arming comparator hysteresis (0 = disable, 1 = enable)"/>
          <node id="CFG_SEL_POL"  address="0x84" mask="0x00000010"  permission="rw"
                description="CFD input charge polarity (0 = positive, 1 = negative/GEM )"/>
          <node id="CFG_FORCE_EN_ZCC"  address="0x84" mask="0x00000008"  permission="rw"
                description="Debug and calibration: force ZCC output, independent from arming comp (0 = disable, 1 = enable)"/>
          <node id="CFG_FORCE_TH"  address="0x84" mask="0x00000004"  permission="rw"
                description="Debug: force active ZCC threshold (0 = disable, 1 = enable)"/>
          <node id="CFG_SEL_COMP_MODE"  address="0x84" mask="0x00000003"  permission="rw"
                description="CFD output mode (00 = normal, 01 = arming, 10 = ZCC, 11 = 0)"/>
          <node id="CFG_VREF_ADC"  address="0x85" mask="0x00000300"  permission="rw"
                description="ADC internal reference tuning, 50mV steps to adjust to 1.0V during production calibration (range: 0-3)"/>
          <node id="CFG_MON_GAIN"  address="0x85" mask="0x00000080"  permission="rw"
                description="Gain of ADC monitoring buffer (0 = gain 1, 1 = gain 5)"/>
          <node id="CFG_MONITOR_SELECT"  address="0x85" mask="0x0000003f"  permission="rw"
                description="Monitoring selection (0 = Imon Iref, 1 = Imon Calib IDC, 2 = Imon Preamp InpTran, 3 = Imon Preamp LC, 4 = Imon Preamp SF, 5 = Imon Shap FC, 6 = Imon Shap Inpair, 7 = Imon SD Inpair, 8 = Imon SD FC, 9 = Imon SD SF, 10 = Imon CFD Bias1, 11 = Imon CFD Bias2, 12 = Imon CFD Hyst, 13 = Imon CFD Ireflocal, 14 = Imon CFD ThArm, 15 = Imon CFD ThZcc, 16 = Imon SLVS Ibias, 32 = Vmon BGR, 33 = Vmon Calib Vstep, 34 = Vmon Preamp Vref, 35 = Vmon Vth Arm, 36 = Vmon Vth ZCC, 37 = V Tsens Int, 38 = V Tsens Ext, 39 = ADC ref, 40 = ADC VinM, 41 = SLVS Vref"/>
          <node id="CFG_IREF"  address="0x86" mask="0x0000003f"  permission="rw"
                description="Tuning of global reference current generated by Bandgap reference circuit. Target value: 10uA. Nominal: 310nA/bit"/>

          <node id="CFG_THR_ZCC_DAC"  address="0x87" mask="0x0000ff00" permission="rw"
                description="ZCC global threshold: nominal 0.5mV/bit (range: 0x00-0xff)"/>
          <node id="CFG_THR_ARM_DAC"  address="0x87" mask="0x000000ff" permission="rw"
                description="Arming global threshold: nominal 2mV/bit (range: 0x00-0xff)"/>

          <node id="CFG_HYST"  address="0x88" mask="0x0000003f" permission="rw"
                description="Global hysteresis DAC: nominal 0.4mV/bit (range: 0x00-0x3f)"/>

          <node id="CFG_LATENCY"  address="0x89" mask="0x0000ffff" permission="rw"
                description="Internal L1A latency (range: 0-1023)"/>

          <node id="CFG_CAL_SEL_POL"  address="0x8a" mask="0x00004000" permission="rw"
                description="Calibration pulse polarity (0 = positive, 1 = negative)"/>
          <node id="CFG_CAL_PHI"  address="0x8a" mask="0x00003800" permission="rw"
                description="Pulse phase in 1/320MHz (3.125ns) delay (range: 0-7, where 0 = no delay and 7 = 21.87ns)"/>
          <node id="CFG_CAL_EXT"  address="0x8a" mask="0x00000400" permission="rw"
                description="External analog voltage step (0 = disable, 1 = enable)"/>
          <node id="CFG_CAL_DAC"  address="0x8a" mask="0x000003fc" permission="rw"
                description="CAL DAC: amplitude of current pulse. 256-CAL DAC: amplitude of voltage step. Range: 0-255"/>
          <node id="CFG_CAL_MODE"  address="0x8a" mask="0x00000003" permission="rw"
                description="Cal pulse mode (00 = disabled, 01 = voltage pulse, 1x = current pulse"/>
          <node id="CFG_CAL_FS"  address="0x8b" mask="0x00000600" permission="rw"
                description="Cal current pulse scale factor. Q = CAL DUR[s] * CAL DAC * 10nA * CAL FS[%] (00 = 25%, 01 = 50%, 10 = 75%, 11 = 100%)"/>
          <node id="CFG_CAL_DUR"  address="0x8b" mask="0x000001ff" permission="rw"
                description="Cal pulse duration in 40MHz clock cycles (range: 0-0x1ff)"/>

          <node id="CFG_BIAS_CFD_DAC_2"  address="0x8c" mask="0x00000fc0" permission="rw"
                description="CFD Bias 2 (current). Range: 0-0x3f (default = 0x28)"/>
          <node id="CFG_BIAS_CFD_DAC_1"  address="0x8c" mask="0x0000003f" permission="rw"
                description="CFD Bias 1 (current). Range: 0-0x3f (default = 0x28)"/>
          <node id="CFG_BIAS_PRE_I_BSF"  address="0x8d" mask="0x00003f00" permission="rw"
                description="Preamplifier bias source follower (current). Range: 0-0x3f (default = 1 = 2uA)"/>
          <node id="CFG_BIAS_PRE_I_BIT"  address="0x8d" mask="0x000000ff" permission="rw"
                description="Preamplifier bias input transistor (current). Range: 0-0xff (default = 1 = 1uA)"/>
          <node id="CFG_BIAS_PRE_I_BLCC"  address="0x8e" mask="0x00003f00" permission="rw"
                description="Preamplifier bias leakage compensation (current). Range: 0-0x3f (default = 15 = 15nA)"/>
          <node id="CFG_BIAS_PRE_VREF"  address="0x8e" mask="0x000000ff" permission="rw"
                description="Preamplifier VREF. Range: 0-0xff (default = 86 = 430mV)"/>
          <node id="CFG_BIAS_SH_I_BFCAS"  address="0x8f" mask="0x0000ff00" permission="rw"
                description="Shaper folded cascode (current). Range: 0-0xff (default = 1 = 100nA)"/>
          <node id="CFG_BIAS_SH_I_BDIFF"  address="0x8f" mask="0x000000ff" permission="rw"
                description="Shaper input pair (current). Range: 0-0xff (default = 1 = 100nA)"/>
          <node id="CFG_BIAS_SH_I_BFAMP"  address="0x90" mask="0x00003f00" permission="rw"
                description="Shaper feed amplifier (current). Range: 0-0x3f (default = 1 = 1nA)"/>
          <node id="CFG_BIAS_SD_I_BDIFF"  address="0x90" mask="0x000000ff" permission="rw"
                description="SD input pair (current). Range: 0-0xff (default = 1 = 100nA)"/>
          <node id="CFG_BIAS_SD_I_BSF"  address="0x91" mask="0x00003f00" permission="rw"
                description="SD source follower (current). Range: 0-0x3f (default = 1 = 2uA)"/>
          <node id="CFG_BIAS_SD_I_BFCAS"  address="0x91" mask="0x000000ff" permission="rw"
                description="SD folded cascode (current). Range: 0-0xff (default = 1 = 100nA)"/>

          <node id="CFG_RUN" address="0x300" mask="0x00000001" permission="rw"
                description="SLEEP/RUN mode (0 = SLEEP, 1 = RUN)"/>

          <node id="HW_ID"  address="0x100"  permission="r"
                description="Device hardware ID register. Reports 0x56464154 (ASCII 'VFAT') on read."/>
          <node id="HW_ID_VER"  address="0x101"  permission="r"
                description="Hardware version. Reports 0x00030000 (v3.0.0) on read."/>
          <node id="TEST_REG"  address="0x102"  permission="rw"
                description="General purpose read/write register."/>
          <node id="HW_CHIP_ID"  address="0x103"  permission="r"
                description="Chip ID from eFuses."/>

          <!-- probably better to leave these out as they should only be used during fusing
          <node id="HW_PROG_TIME"  address="0x104" mask="0x0007ff00" permission="w"
                description="eFuse: program time in 25ns units. Range: 0-0x7ff"/>
          <node id="HW_PROG_BIT_ADDR"  address="0x104" mask="0x0000001f" permission="w"
                description="eFuse: address of the bit to be programmed. Range: 0-0x1f"/>
          -->

          <node id="ADC0_CACHED"  address="0x280" mask="0x000003ff" permission="r"
                description="Primary ADC read (using the internal reference). Note, this value is returned from CTP7's cache (last known value of ADC0 for this VFAT since ADC0_UPDATE was called). To update the cache, read or write ADC0_UPDATE, and wait at least 20us before reading this register to take the updated value (note that value of 0 indicates a read error)"/>
          <node id="ADC0_UPDATE"  address="0x200" mask="0x00000001" permission="rw"
                description="Reading or writing this register will trigger a read of the ADC0 value form this VFAT and update of the cache. The read from the VFAT takes aroun 11us, so it's advised to wait for 20us to be sure that the cache was already updated before reading ADC0_CACHED"/>

          <node id="ADC1_CACHED"  address="0x281" mask="0x000003ff" permission="r"
                description="ADC1 read (using the external reference). Note, this value is returned from CTP7's cache. To update the cache, read or write ADC1_UPDATE, and wait at least 20us before reading this register to take the updated value (note that value of 0 indicates a read error)"/>
          <node id="ADC1_UPDATE"  address="0x201" mask="0x00000001" permission="rw"
                description="Reading or writing this register will trigger a read of the ADC1 value form this VFAT and update of the cache. The read from the VFAT takes aroun 11us, so it's advised to wait for 20us to be sure that the cache was already updated before reading ADC1_CACHED"/>


        </node>
    </node>

  </node> <!-- end OH${OH_IDX} block -->
</node> <!-- end OptoHybrid block -->

<!--Config Blaster module -->
<node id="CONFIG_BLASTER"  address="0x00c00000"
      description="Configuration Blaster. This module stores configuration data for all GBTXs, VFAT3s, and OH FPGAs, and then streams this configuration data to each device after a hard-reset."
      fw_is_module="true"
      fw_is_module_external="true">

  <node id="CTRL" address="0x0">
    <node id="BLASTER_ENABLE" address="0x0" mask="0x00000001" permission="rw"
          description="Set this to 1 to enable the configuration blasting after the hard reset. By default this is disabled, because config RAM is empty on startup, so only enable this after the config RAM has been written with valid config data."/>
  </node>

  <node id="STATUS" address="0x100">
    <node id="GBT_RAM_SIZE" address="0x0" permission="r" description="Size of the GBT config RAM (in 32bit words, or number of available addresses)"/>
    <node id="VFAT_RAM_SIZE" address="0x1" permission="r" description="Size of the VFAT config RAM (in 32bit words, or number of available addresses)"/>
    <node id="OH_RAM_SIZE" address="0x2" permission="r" description="Size of the OH config RAM (in 32bit words, or number of available addresses)"/>
  </node>

  <node id="RAM" address="0x10000">
    <node id="GBT" address="0x00000" mode="block" size="3312" permission="rw"
          description="Configuration RAM for GBTX chips. Each GBTX has 366 x 8bit registers, and each address in this RAM holds 4 register values in LSB format (so in total there are 92 RAM addresses for each chip, where the last one is only partially filled).
                       The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                       RAM size is also provided in the STATUS registers of this module.
                       If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>
    <node id="VFAT" address="0x10000" mode="block" size="21312" permission="rw"
          description="Configuration RAM for VFAT chips. Each VFAT has 147 x 16bit registers, and each address in this RAM holds 2 register values in LSB format (so in total there are 74 RAM addresses for each chip, where the last one is only partially filled).
                       The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                       RAM size is also provided in the STATUS registers of this module.
                       If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>

    <node id="OH_FPGA" address="0x20000" mode="block" size="2400" permission="rw"
          description="Configuration RAM for OH FPGAs. 100 32bit registers are allocated for each OH at the moment. For each register, a 32bit OH register address (local to OH address space) has to be written to this RAM, followed by a 32bit register value.
                       The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                       RAM size is also provided in the STATUS registers of this module.
                       If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>
    <node id="GBT_OH${OH_IDX}"  address="0x00000" mode="block" size="276" permission="rw"
          description="GBTX configuration RAM pointer to OH${OH_IDX}. This part of the RAM contains configuration of all 3 GBTXs for this OH."
    generate="true" generate_size="&NUM_OHS;" generate_address_step="0x144" generate_idx_var="OH_IDX"/>
    <node id="VFAT_OH${OH_IDX}"  address="0x10000" mode="block" size="1776" permission="rw"
          description="VFAT configuration RAM pointer to OH#${OH_IDX}. This part of the RAM contains configuration of all 24 VFATs for this OH."
    generate="true" generate_size="&NUM_OHS;" generate_address_step="0x6f0" generate_idx_var="OH_IDX"/>
    <node id="OH_FPGA_OH${OH_IDX}"  address="0x20000" mode="block" size="200" permission="rw"
          description="OH FPGA configuration RAM pointer to OH#${OH_IDX}."
    generate="true" generate_size="&NUM_OHS;" generate_address_step="0xc8" generate_idx_var="OH_IDX"/>
  </node>

</node> <!-- end Config Blaster block -->
